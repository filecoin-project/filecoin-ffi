#!/usr/bin/env bash

set -Exeo pipefail

# set CWD to the root of filecoin-ffi
#
cd "$(dirname "${BASH_SOURCE[0]}")"

# tracks where the Rust sources are were we to build locally instead of
# downloading from GitHub Releases
#
rust_sources_dir="rust"

# an array of values passed as 'target-feature' to the Rust compiler if we're
# building an optimized libfilecoin (which takes advantage of some perf-boosting
# instruction sets)
#
optimized_release_rustc_target_features=($(cat "${rust_sources_dir}/rustc-target-features-optimized.json" | jq -r '.[].rustc_target_feature'))

# each value in this area is checked against the "features" of the hosts CPU
# in order to determine if the host is suitable for an optimized release
#
cpu_features_required_for_optimized_release=($(cat "${rust_sources_dir}/rustc-target-features-optimized.json" | jq -r '.[].check_cpu_for_feature | select(. != null)'))

main() {
    if [ "${FFI_BUILD_FROM_SOURCE}" != "1" ] && download_release_tarball __tarball_path "${rust_sources_dir}" "filecoin-ffi" $(get_release_type); then
        local __tmp_dir=$(mktemp -d)

        # extract downloaded tarball to temporary directory
        #
        tar -C "$__tmp_dir" -xzf "$__tarball_path"

        # copy build assets into root of filecoin-ffi
        #
        find -L "${__tmp_dir}" -type f -name filecoin.h -exec cp -- "{}" . \;
        find -L "${__tmp_dir}" -type f -name libfilecoin.a -exec cp -- "{}" . \;
        find -L "${__tmp_dir}" -type f -name filecoin.pc -exec cp -- "{}" . \;

        (>&2 echo "[install-filecoin/main] successfully installed prebuilt libfilecoin")
    else
        (>&2 echo "[install-filecoin/main] building libfilecoin from local sources (dir = ${rust_sources_dir})")

        # build libfilecoin (and corresponding header and pkg-config)
        #
        build_from_source "filecoin" "${rust_sources_dir}" $(get_release_type)

        # copy from Rust's build directory (target) to root of filecoin-ffi
        #
        find -L "${rust_sources_dir}/target/release" -type f -name filecoin.h -exec cp -- "{}" . \;
        find -L "${rust_sources_dir}/target/release" -type f -name libfilecoin.a -exec cp -- "{}" . \;
        find -L "${rust_sources_dir}" -type f -name filecoin.pc -exec cp -- "{}" . \;

        if [[ ! -f "./filecoin.h" ]]; then
            (>&2 echo "[install-filecoin/main] failed to install filecoin.h")
            exit 1
        fi

        if [[ ! -f "./libfilecoin.a" ]]; then
            (>&2 echo "[install-filecoin/main] failed to install libfilecoin.a")
            exit 1
        fi

        if [[ ! -f "./filecoin.pc" ]]; then
            (>&2 echo "[install-filecoin/main] failed to install filecoin.pc")
            exit 1
        fi

        (>&2 echo "[install-filecoin/main] successfully built and installed libfilecoin from source")
    fi
}

download_release_tarball() {
    local __resultvar=$1
    local __rust_sources_path=$2
    local __repo_name=$3
    local __release_type=$4
    local __release_sha1=$(git rev-parse HEAD)
    local __release_tag="${__release_sha1:0:16}"
    local __release_tag_url="https://api.github.com/repos/filecoin-project/${__repo_name}/releases/tags/${__release_tag}"

    # TODO: This function shouldn't make assumptions about how these releases'
    # names are constructed. Marginally less-bad would be to require that this
    # function's caller provide the release name.
    #
    local __release_name="${__repo_name}-$(uname)-${__release_type}"

    (>&2 echo "[download_release_tarball] acquiring release @ ${__release_tag}")

    local __release_response=$(curl \
        --retry 3 \
        --location $__release_tag_url)

    local __release_url=$(echo $__release_response | jq -r ".assets[] | select(.name | contains(\"${__release_name}\")) | .url")

    local __tar_path="/tmp/${__release_name}_$(basename ${__release_url}).tar.gz"

    if [[ -z "$__release_url" ]]; then
        (>&2 echo "[download_release_tarball] failed to download release (tag URL: ${__release_tag_url}, response: ${__release_response})")
        return 1
    fi

    local __asset_url=$(curl \
        --head \
        --retry 3 \
        --header "Accept:application/octet-stream" \
        --location \
        --output /dev/null \
        -w %{url_effective} \
        "$__release_url")

    curl --retry 3 --output "${__tar_path}" "$__asset_url"
    if [[ $? -ne "0" ]]; then
        (>&2 echo "[download_release_tarball] failed to download release asset (tag URL: ${__release_tag_url}, asset URL: ${__asset_url})")
        return 1
    fi

    # set $__resultvar (which the caller provided as $1), which is the poor
    # man's way of returning a value from a function in Bash
    #
    eval $__resultvar="'$__tar_path'"
}

build_from_source() {
    local __library_name=$1
    local __rust_sources_path=$2
    local __release_type=$3
    local __repo_sha1=$(git rev-parse HEAD)
    local __repo_sha1_truncated="${__repo_sha1:0:16}"
    local __target_feature=""

    (>&2 echo "building from source @ ${__repo_sha1_truncated}")

    if ! [ -x "$(command -v cargo)" ]; then
        (>&2 echo '[build_from_source] Error: cargo is not installed.')
        (>&2 echo '[build_from_source] install Rust toolchain to resolve this problem.')
        exit 1
    fi

    if ! [ -x "$(command -v rustup)" ]; then
        (>&2 echo '[build_from_source] Error: rustup is not installed.')
        (>&2 echo '[build_from_source] install Rust toolchain installer to resolve this problem.')
        exit 1
    fi

    pushd $__rust_sources_path

    cargo --version

    # reduce array of features into the rustc-specific 'target-feature' flag
    for x in ${optimized_release_rustc_target_features[@]}; do
        __target_feature="${x},${__target_feature}"
    done

    if [ "${__release_type}" = "optimized" ]; then
        RUSTFLAGS="-C target-feature=${__target_feature}" ./scripts/build-release.sh $__library_name $(cat rust-toolchain)
    else
        ./scripts/build-release.sh $__library_name $(cat rust-toolchain)
    fi

    popd
}

get_release_type() {
    local __searched=""
    local __features=""
    local __optimized=true

    # determine where to look for CPU features
    #
    if [[ ! -f "/proc/cpuinfo" ]]; then
        (>&2 echo "[get_release_type] no /proc/cpuinfo file; falling back to Darwin feature detection")
        __searched="sysctl -a | grep machdep.cpu | tr '[:upper:]' '[:lower:]' | grep features"
    else
        __searched="cat /proc/cpuinfo | grep flags"
    fi
    __features=$(eval "$__searched")

    # check for the presence of each required CPU feature
    #
    for x in ${cpu_features_required_for_optimized_release[@]}; do
        if [ "$__optimized" = true ]; then
            if ! [ -z "${__features##*$x*}" ]; then
                (>&2 echo "[get_release_type] your CPU does not support the '${x}' feature (searched '${__searched}')")
                __optimized=false
            fi
        fi
    done

    # if we couldn't figure out where to look for features, use standard
    #
    if [ "$__optimized" == true ] && ! [ -z "$__features" ]; then
        (>&2 echo "[get_release_type] configuring 'optimized' build")
        echo "optimized"
    else
        (>&2 echo "[get_release_type] configuring 'standard' build")
        echo "standard"
    fi
}

main "$@"; exit
