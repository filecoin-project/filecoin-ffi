// WARNING: This file has automatically been generated
// Code generated by https://git.io/c-for-go. DO NOT EDIT.

package generated

/*
#cgo LDFLAGS: -L${SRCDIR}/.. -lfilecoin
#cgo pkg-config: ${SRCDIR}/../filecoin.pc
#include "../filecoin.h"
#include <stdlib.h>
#include "cgo_helpers.h"
*/
import "C"
import (
	"runtime"
	"sync"
	"unsafe"
)

// cgoAllocMap stores pointers to C allocated memory for future reference.
type cgoAllocMap struct {
	mux sync.RWMutex
	m   map[unsafe.Pointer]struct{}
}

var cgoAllocsUnknown = new(cgoAllocMap)

func (a *cgoAllocMap) Add(ptr unsafe.Pointer) {
	a.mux.Lock()
	if a.m == nil {
		a.m = make(map[unsafe.Pointer]struct{})
	}
	a.m[ptr] = struct{}{}
	a.mux.Unlock()
}

func (a *cgoAllocMap) IsEmpty() bool {
	a.mux.RLock()
	isEmpty := len(a.m) == 0
	a.mux.RUnlock()
	return isEmpty
}

func (a *cgoAllocMap) Borrow(b *cgoAllocMap) {
	if b == nil || b.IsEmpty() {
		return
	}
	b.mux.Lock()
	a.mux.Lock()
	for ptr := range b.m {
		if a.m == nil {
			a.m = make(map[unsafe.Pointer]struct{})
		}
		a.m[ptr] = struct{}{}
		delete(b.m, ptr)
	}
	a.mux.Unlock()
	b.mux.Unlock()
}

func (a *cgoAllocMap) Free() {
	a.mux.Lock()
	for ptr := range a.m {
		C.free(ptr)
		delete(a.m, ptr)
	}
	a.mux.Unlock()
}

// allocFilBLSSignatureMemory allocates memory for type C.fil_BLSSignature in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilBLSSignatureMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilBLSSignatureValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFilBLSSignatureValue = unsafe.Sizeof([1]C.fil_BLSSignature{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilBLSSignature) Ref() *C.fil_BLSSignature {
	if x == nil {
		return nil
	}
	return x.refa2ac09ba
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilBLSSignature) Free() {
	if x != nil && x.allocsa2ac09ba != nil {
		x.allocsa2ac09ba.(*cgoAllocMap).Free()
		x.refa2ac09ba = nil
	}
}

// NewFilBLSSignatureRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilBLSSignatureRef(ref unsafe.Pointer) *FilBLSSignature {
	if ref == nil {
		return nil
	}
	obj := new(FilBLSSignature)
	obj.refa2ac09ba = (*C.fil_BLSSignature)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilBLSSignature) PassRef() (*C.fil_BLSSignature, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa2ac09ba != nil {
		return x.refa2ac09ba, nil
	}
	mema2ac09ba := allocFilBLSSignatureMemory(1)
	refa2ac09ba := (*C.fil_BLSSignature)(mema2ac09ba)
	allocsa2ac09ba := new(cgoAllocMap)
	allocsa2ac09ba.Add(mema2ac09ba)

	var cinner_allocs *cgoAllocMap
	refa2ac09ba.inner, cinner_allocs = *(*[96]C.uint8_t)(unsafe.Pointer(&x.Inner)), cgoAllocsUnknown
	allocsa2ac09ba.Borrow(cinner_allocs)

	x.refa2ac09ba = refa2ac09ba
	x.allocsa2ac09ba = allocsa2ac09ba
	return refa2ac09ba, allocsa2ac09ba

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilBLSSignature) PassValue() (C.fil_BLSSignature, *cgoAllocMap) {
	if x.refa2ac09ba != nil {
		return *x.refa2ac09ba, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilBLSSignature) Deref() {
	if x.refa2ac09ba == nil {
		return
	}
	x.Inner = *(*[96]byte)(unsafe.Pointer(&x.refa2ac09ba.inner))
}

// allocFilAggregateResponseMemory allocates memory for type C.fil_AggregateResponse in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilAggregateResponseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilAggregateResponseValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFilAggregateResponseValue = unsafe.Sizeof([1]C.fil_AggregateResponse{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilAggregateResponse) Ref() *C.fil_AggregateResponse {
	if x == nil {
		return nil
	}
	return x.refb3efa36d
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilAggregateResponse) Free() {
	if x != nil && x.allocsb3efa36d != nil {
		x.allocsb3efa36d.(*cgoAllocMap).Free()
		x.refb3efa36d = nil
	}
}

// NewFilAggregateResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilAggregateResponseRef(ref unsafe.Pointer) *FilAggregateResponse {
	if ref == nil {
		return nil
	}
	obj := new(FilAggregateResponse)
	obj.refb3efa36d = (*C.fil_AggregateResponse)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilAggregateResponse) PassRef() (*C.fil_AggregateResponse, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb3efa36d != nil {
		return x.refb3efa36d, nil
	}
	memb3efa36d := allocFilAggregateResponseMemory(1)
	refb3efa36d := (*C.fil_AggregateResponse)(memb3efa36d)
	allocsb3efa36d := new(cgoAllocMap)
	allocsb3efa36d.Add(memb3efa36d)

	var csignature_allocs *cgoAllocMap
	refb3efa36d.signature, csignature_allocs = x.Signature.PassValue()
	allocsb3efa36d.Borrow(csignature_allocs)

	x.refb3efa36d = refb3efa36d
	x.allocsb3efa36d = allocsb3efa36d
	return refb3efa36d, allocsb3efa36d

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilAggregateResponse) PassValue() (C.fil_AggregateResponse, *cgoAllocMap) {
	if x.refb3efa36d != nil {
		return *x.refb3efa36d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilAggregateResponse) Deref() {
	if x.refb3efa36d == nil {
		return
	}
	x.Signature = *NewFilBLSSignatureRef(unsafe.Pointer(&x.refb3efa36d.signature))
}

// allocFilClearCacheResponseMemory allocates memory for type C.fil_ClearCacheResponse in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilClearCacheResponseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilClearCacheResponseValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFilClearCacheResponseValue = unsafe.Sizeof([1]C.fil_ClearCacheResponse{})

// unpackPCharString represents the data from Go string as *C.char and avoids copying.
func unpackPCharString(str string) (*C.char, *cgoAllocMap) {
	str = safeString(str)
	h := (*stringHeader)(unsafe.Pointer(&str))
	return (*C.char)(h.Data), cgoAllocsUnknown
}

type stringHeader struct {
	Data unsafe.Pointer
	Len  int
}

// safeString ensures that the string is NULL-terminated, a NULL-terminated copy is created otherwise.
func safeString(str string) string {
	if len(str) > 0 && str[len(str)-1] != '\x00' {
		str = str + "\x00"
	} else if len(str) == 0 {
		str = "\x00"
	}
	return str
}

// packPCharString creates a Go string backed by *C.char and avoids copying.
func packPCharString(p *C.char) (raw string) {
	if p != nil && *p != 0 {
		h := (*stringHeader)(unsafe.Pointer(&raw))
		h.Data = unsafe.Pointer(p)
		for *p != 0 {
			p = (*C.char)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1)) // p++
		}
		h.Len = int(uintptr(unsafe.Pointer(p)) - uintptr(h.Data))
	}
	return
}

// RawString reperesents a string backed by data on the C side.
type RawString string

// Copy returns a Go-managed copy of raw string.
func (raw RawString) Copy() string {
	if len(raw) == 0 {
		return ""
	}
	h := (*stringHeader)(unsafe.Pointer(&raw))
	return C.GoStringN((*C.char)(h.Data), C.int(h.Len))
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilClearCacheResponse) Ref() *C.fil_ClearCacheResponse {
	if x == nil {
		return nil
	}
	return x.refa9a80400
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilClearCacheResponse) Free() {
	if x != nil && x.allocsa9a80400 != nil {
		x.allocsa9a80400.(*cgoAllocMap).Free()
		x.refa9a80400 = nil
	}
}

// NewFilClearCacheResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilClearCacheResponseRef(ref unsafe.Pointer) *FilClearCacheResponse {
	if ref == nil {
		return nil
	}
	obj := new(FilClearCacheResponse)
	obj.refa9a80400 = (*C.fil_ClearCacheResponse)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilClearCacheResponse) PassRef() (*C.fil_ClearCacheResponse, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa9a80400 != nil {
		return x.refa9a80400, nil
	}
	mema9a80400 := allocFilClearCacheResponseMemory(1)
	refa9a80400 := (*C.fil_ClearCacheResponse)(mema9a80400)
	allocsa9a80400 := new(cgoAllocMap)
	allocsa9a80400.Add(mema9a80400)

	var cerror_msg_allocs *cgoAllocMap
	refa9a80400.error_msg, cerror_msg_allocs = unpackPCharString(x.ErrorMsg)
	allocsa9a80400.Borrow(cerror_msg_allocs)

	var cstatus_code_allocs *cgoAllocMap
	refa9a80400.status_code, cstatus_code_allocs = (C.FCPResponseStatus)(x.StatusCode), cgoAllocsUnknown
	allocsa9a80400.Borrow(cstatus_code_allocs)

	x.refa9a80400 = refa9a80400
	x.allocsa9a80400 = allocsa9a80400
	return refa9a80400, allocsa9a80400

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilClearCacheResponse) PassValue() (C.fil_ClearCacheResponse, *cgoAllocMap) {
	if x.refa9a80400 != nil {
		return *x.refa9a80400, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilClearCacheResponse) Deref() {
	if x.refa9a80400 == nil {
		return
	}
	x.ErrorMsg = packPCharString(x.refa9a80400.error_msg)
	x.StatusCode = (FCPResponseStatus)(x.refa9a80400.status_code)
}

// allocFilFinalizeTicketResponseMemory allocates memory for type C.fil_FinalizeTicketResponse in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilFinalizeTicketResponseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilFinalizeTicketResponseValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFilFinalizeTicketResponseValue = unsafe.Sizeof([1]C.fil_FinalizeTicketResponse{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilFinalizeTicketResponse) Ref() *C.fil_FinalizeTicketResponse {
	if x == nil {
		return nil
	}
	return x.refb370fa86
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilFinalizeTicketResponse) Free() {
	if x != nil && x.allocsb370fa86 != nil {
		x.allocsb370fa86.(*cgoAllocMap).Free()
		x.refb370fa86 = nil
	}
}

// NewFilFinalizeTicketResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilFinalizeTicketResponseRef(ref unsafe.Pointer) *FilFinalizeTicketResponse {
	if ref == nil {
		return nil
	}
	obj := new(FilFinalizeTicketResponse)
	obj.refb370fa86 = (*C.fil_FinalizeTicketResponse)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilFinalizeTicketResponse) PassRef() (*C.fil_FinalizeTicketResponse, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb370fa86 != nil {
		return x.refb370fa86, nil
	}
	memb370fa86 := allocFilFinalizeTicketResponseMemory(1)
	refb370fa86 := (*C.fil_FinalizeTicketResponse)(memb370fa86)
	allocsb370fa86 := new(cgoAllocMap)
	allocsb370fa86.Add(memb370fa86)

	var cstatus_code_allocs *cgoAllocMap
	refb370fa86.status_code, cstatus_code_allocs = (C.FCPResponseStatus)(x.StatusCode), cgoAllocsUnknown
	allocsb370fa86.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	refb370fa86.error_msg, cerror_msg_allocs = unpackPCharString(x.ErrorMsg)
	allocsb370fa86.Borrow(cerror_msg_allocs)

	var cticket_allocs *cgoAllocMap
	refb370fa86.ticket, cticket_allocs = *(*[32]C.uint8_t)(unsafe.Pointer(&x.Ticket)), cgoAllocsUnknown
	allocsb370fa86.Borrow(cticket_allocs)

	x.refb370fa86 = refb370fa86
	x.allocsb370fa86 = allocsb370fa86
	return refb370fa86, allocsb370fa86

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilFinalizeTicketResponse) PassValue() (C.fil_FinalizeTicketResponse, *cgoAllocMap) {
	if x.refb370fa86 != nil {
		return *x.refb370fa86, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilFinalizeTicketResponse) Deref() {
	if x.refb370fa86 == nil {
		return
	}
	x.StatusCode = (FCPResponseStatus)(x.refb370fa86.status_code)
	x.ErrorMsg = packPCharString(x.refb370fa86.error_msg)
	x.Ticket = *(*[32]byte)(unsafe.Pointer(&x.refb370fa86.ticket))
}

// allocFilCandidateMemory allocates memory for type C.fil_Candidate in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilCandidateMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilCandidateValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFilCandidateValue = unsafe.Sizeof([1]C.fil_Candidate{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilCandidate) Ref() *C.fil_Candidate {
	if x == nil {
		return nil
	}
	return x.refaa02d4eb
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilCandidate) Free() {
	if x != nil && x.allocsaa02d4eb != nil {
		x.allocsaa02d4eb.(*cgoAllocMap).Free()
		x.refaa02d4eb = nil
	}
}

// NewFilCandidateRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilCandidateRef(ref unsafe.Pointer) *FilCandidate {
	if ref == nil {
		return nil
	}
	obj := new(FilCandidate)
	obj.refaa02d4eb = (*C.fil_Candidate)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilCandidate) PassRef() (*C.fil_Candidate, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refaa02d4eb != nil {
		return x.refaa02d4eb, nil
	}
	memaa02d4eb := allocFilCandidateMemory(1)
	refaa02d4eb := (*C.fil_Candidate)(memaa02d4eb)
	allocsaa02d4eb := new(cgoAllocMap)
	allocsaa02d4eb.Add(memaa02d4eb)

	var csector_id_allocs *cgoAllocMap
	refaa02d4eb.sector_id, csector_id_allocs = (C.uint64_t)(x.SectorId), cgoAllocsUnknown
	allocsaa02d4eb.Borrow(csector_id_allocs)

	var cpartial_ticket_allocs *cgoAllocMap
	refaa02d4eb.partial_ticket, cpartial_ticket_allocs = *(*[32]C.uint8_t)(unsafe.Pointer(&x.PartialTicket)), cgoAllocsUnknown
	allocsaa02d4eb.Borrow(cpartial_ticket_allocs)

	var cticket_allocs *cgoAllocMap
	refaa02d4eb.ticket, cticket_allocs = *(*[32]C.uint8_t)(unsafe.Pointer(&x.Ticket)), cgoAllocsUnknown
	allocsaa02d4eb.Borrow(cticket_allocs)

	var csector_challenge_index_allocs *cgoAllocMap
	refaa02d4eb.sector_challenge_index, csector_challenge_index_allocs = (C.uint64_t)(x.SectorChallengeIndex), cgoAllocsUnknown
	allocsaa02d4eb.Borrow(csector_challenge_index_allocs)

	x.refaa02d4eb = refaa02d4eb
	x.allocsaa02d4eb = allocsaa02d4eb
	return refaa02d4eb, allocsaa02d4eb

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilCandidate) PassValue() (C.fil_Candidate, *cgoAllocMap) {
	if x.refaa02d4eb != nil {
		return *x.refaa02d4eb, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilCandidate) Deref() {
	if x.refaa02d4eb == nil {
		return
	}
	x.SectorId = (uint64)(x.refaa02d4eb.sector_id)
	x.PartialTicket = *(*[32]byte)(unsafe.Pointer(&x.refaa02d4eb.partial_ticket))
	x.Ticket = *(*[32]byte)(unsafe.Pointer(&x.refaa02d4eb.ticket))
	x.SectorChallengeIndex = (uint64)(x.refaa02d4eb.sector_challenge_index)
}

// allocFilGenerateCandidatesResponseMemory allocates memory for type C.fil_GenerateCandidatesResponse in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilGenerateCandidatesResponseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilGenerateCandidatesResponseValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFilGenerateCandidatesResponseValue = unsafe.Sizeof([1]C.fil_GenerateCandidatesResponse{})

type sliceHeader struct {
	Data unsafe.Pointer
	Len  int
	Cap  int
}

const sizeOfPtr = unsafe.Sizeof(&struct{}{})

// unpackSFilCandidate transforms a sliced Go data structure into plain C format.
func unpackSFilCandidate(x []FilCandidate) (unpacked *C.fil_Candidate, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.fil_Candidate) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocFilCandidateMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.fil_Candidate)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.fil_Candidate)(h.Data)
	return
}

// packSFilCandidate reads sliced Go data structure out from plain C format.
func packSFilCandidate(v []FilCandidate, ptr0 *C.fil_Candidate) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfFilCandidateValue]C.fil_Candidate)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewFilCandidateRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilGenerateCandidatesResponse) Ref() *C.fil_GenerateCandidatesResponse {
	if x == nil {
		return nil
	}
	return x.ref1b9cd8d8
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilGenerateCandidatesResponse) Free() {
	if x != nil && x.allocs1b9cd8d8 != nil {
		x.allocs1b9cd8d8.(*cgoAllocMap).Free()
		x.ref1b9cd8d8 = nil
	}
}

// NewFilGenerateCandidatesResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilGenerateCandidatesResponseRef(ref unsafe.Pointer) *FilGenerateCandidatesResponse {
	if ref == nil {
		return nil
	}
	obj := new(FilGenerateCandidatesResponse)
	obj.ref1b9cd8d8 = (*C.fil_GenerateCandidatesResponse)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilGenerateCandidatesResponse) PassRef() (*C.fil_GenerateCandidatesResponse, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref1b9cd8d8 != nil {
		return x.ref1b9cd8d8, nil
	}
	mem1b9cd8d8 := allocFilGenerateCandidatesResponseMemory(1)
	ref1b9cd8d8 := (*C.fil_GenerateCandidatesResponse)(mem1b9cd8d8)
	allocs1b9cd8d8 := new(cgoAllocMap)
	allocs1b9cd8d8.Add(mem1b9cd8d8)

	var cerror_msg_allocs *cgoAllocMap
	ref1b9cd8d8.error_msg, cerror_msg_allocs = unpackPCharString(x.ErrorMsg)
	allocs1b9cd8d8.Borrow(cerror_msg_allocs)

	var cstatus_code_allocs *cgoAllocMap
	ref1b9cd8d8.status_code, cstatus_code_allocs = (C.FCPResponseStatus)(x.StatusCode), cgoAllocsUnknown
	allocs1b9cd8d8.Borrow(cstatus_code_allocs)

	var ccandidates_ptr_allocs *cgoAllocMap
	ref1b9cd8d8.candidates_ptr, ccandidates_ptr_allocs = unpackSFilCandidate(x.CandidatesPtr)
	allocs1b9cd8d8.Borrow(ccandidates_ptr_allocs)

	var ccandidates_len_allocs *cgoAllocMap
	ref1b9cd8d8.candidates_len, ccandidates_len_allocs = (C.size_t)(x.CandidatesLen), cgoAllocsUnknown
	allocs1b9cd8d8.Borrow(ccandidates_len_allocs)

	x.ref1b9cd8d8 = ref1b9cd8d8
	x.allocs1b9cd8d8 = allocs1b9cd8d8
	return ref1b9cd8d8, allocs1b9cd8d8

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilGenerateCandidatesResponse) PassValue() (C.fil_GenerateCandidatesResponse, *cgoAllocMap) {
	if x.ref1b9cd8d8 != nil {
		return *x.ref1b9cd8d8, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilGenerateCandidatesResponse) Deref() {
	if x.ref1b9cd8d8 == nil {
		return
	}
	x.ErrorMsg = packPCharString(x.ref1b9cd8d8.error_msg)
	x.StatusCode = (FCPResponseStatus)(x.ref1b9cd8d8.status_code)
	packSFilCandidate(x.CandidatesPtr, x.ref1b9cd8d8.candidates_ptr)
	x.CandidatesLen = (uint)(x.ref1b9cd8d8.candidates_len)
}

// allocFilGenerateDataCommitmentResponseMemory allocates memory for type C.fil_GenerateDataCommitmentResponse in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilGenerateDataCommitmentResponseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilGenerateDataCommitmentResponseValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFilGenerateDataCommitmentResponseValue = unsafe.Sizeof([1]C.fil_GenerateDataCommitmentResponse{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilGenerateDataCommitmentResponse) Ref() *C.fil_GenerateDataCommitmentResponse {
	if x == nil {
		return nil
	}
	return x.ref87da7dd9
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilGenerateDataCommitmentResponse) Free() {
	if x != nil && x.allocs87da7dd9 != nil {
		x.allocs87da7dd9.(*cgoAllocMap).Free()
		x.ref87da7dd9 = nil
	}
}

// NewFilGenerateDataCommitmentResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilGenerateDataCommitmentResponseRef(ref unsafe.Pointer) *FilGenerateDataCommitmentResponse {
	if ref == nil {
		return nil
	}
	obj := new(FilGenerateDataCommitmentResponse)
	obj.ref87da7dd9 = (*C.fil_GenerateDataCommitmentResponse)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilGenerateDataCommitmentResponse) PassRef() (*C.fil_GenerateDataCommitmentResponse, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref87da7dd9 != nil {
		return x.ref87da7dd9, nil
	}
	mem87da7dd9 := allocFilGenerateDataCommitmentResponseMemory(1)
	ref87da7dd9 := (*C.fil_GenerateDataCommitmentResponse)(mem87da7dd9)
	allocs87da7dd9 := new(cgoAllocMap)
	allocs87da7dd9.Add(mem87da7dd9)

	var cstatus_code_allocs *cgoAllocMap
	ref87da7dd9.status_code, cstatus_code_allocs = (C.FCPResponseStatus)(x.StatusCode), cgoAllocsUnknown
	allocs87da7dd9.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	ref87da7dd9.error_msg, cerror_msg_allocs = unpackPCharString(x.ErrorMsg)
	allocs87da7dd9.Borrow(cerror_msg_allocs)

	var ccomm_d_allocs *cgoAllocMap
	ref87da7dd9.comm_d, ccomm_d_allocs = *(*[32]C.uint8_t)(unsafe.Pointer(&x.CommD)), cgoAllocsUnknown
	allocs87da7dd9.Borrow(ccomm_d_allocs)

	x.ref87da7dd9 = ref87da7dd9
	x.allocs87da7dd9 = allocs87da7dd9
	return ref87da7dd9, allocs87da7dd9

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilGenerateDataCommitmentResponse) PassValue() (C.fil_GenerateDataCommitmentResponse, *cgoAllocMap) {
	if x.ref87da7dd9 != nil {
		return *x.ref87da7dd9, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilGenerateDataCommitmentResponse) Deref() {
	if x.ref87da7dd9 == nil {
		return
	}
	x.StatusCode = (FCPResponseStatus)(x.ref87da7dd9.status_code)
	x.ErrorMsg = packPCharString(x.ref87da7dd9.error_msg)
	x.CommD = *(*[32]byte)(unsafe.Pointer(&x.ref87da7dd9.comm_d))
}

// allocFilGeneratePieceCommitmentResponseMemory allocates memory for type C.fil_GeneratePieceCommitmentResponse in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilGeneratePieceCommitmentResponseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilGeneratePieceCommitmentResponseValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFilGeneratePieceCommitmentResponseValue = unsafe.Sizeof([1]C.fil_GeneratePieceCommitmentResponse{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilGeneratePieceCommitmentResponse) Ref() *C.fil_GeneratePieceCommitmentResponse {
	if x == nil {
		return nil
	}
	return x.ref4b00fda4
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilGeneratePieceCommitmentResponse) Free() {
	if x != nil && x.allocs4b00fda4 != nil {
		x.allocs4b00fda4.(*cgoAllocMap).Free()
		x.ref4b00fda4 = nil
	}
}

// NewFilGeneratePieceCommitmentResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilGeneratePieceCommitmentResponseRef(ref unsafe.Pointer) *FilGeneratePieceCommitmentResponse {
	if ref == nil {
		return nil
	}
	obj := new(FilGeneratePieceCommitmentResponse)
	obj.ref4b00fda4 = (*C.fil_GeneratePieceCommitmentResponse)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilGeneratePieceCommitmentResponse) PassRef() (*C.fil_GeneratePieceCommitmentResponse, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref4b00fda4 != nil {
		return x.ref4b00fda4, nil
	}
	mem4b00fda4 := allocFilGeneratePieceCommitmentResponseMemory(1)
	ref4b00fda4 := (*C.fil_GeneratePieceCommitmentResponse)(mem4b00fda4)
	allocs4b00fda4 := new(cgoAllocMap)
	allocs4b00fda4.Add(mem4b00fda4)

	var cstatus_code_allocs *cgoAllocMap
	ref4b00fda4.status_code, cstatus_code_allocs = (C.FCPResponseStatus)(x.StatusCode), cgoAllocsUnknown
	allocs4b00fda4.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	ref4b00fda4.error_msg, cerror_msg_allocs = unpackPCharString(x.ErrorMsg)
	allocs4b00fda4.Borrow(cerror_msg_allocs)

	var ccomm_p_allocs *cgoAllocMap
	ref4b00fda4.comm_p, ccomm_p_allocs = *(*[32]C.uint8_t)(unsafe.Pointer(&x.CommP)), cgoAllocsUnknown
	allocs4b00fda4.Borrow(ccomm_p_allocs)

	var cnum_bytes_aligned_allocs *cgoAllocMap
	ref4b00fda4.num_bytes_aligned, cnum_bytes_aligned_allocs = (C.uint64_t)(x.NumBytesAligned), cgoAllocsUnknown
	allocs4b00fda4.Borrow(cnum_bytes_aligned_allocs)

	x.ref4b00fda4 = ref4b00fda4
	x.allocs4b00fda4 = allocs4b00fda4
	return ref4b00fda4, allocs4b00fda4

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilGeneratePieceCommitmentResponse) PassValue() (C.fil_GeneratePieceCommitmentResponse, *cgoAllocMap) {
	if x.ref4b00fda4 != nil {
		return *x.ref4b00fda4, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilGeneratePieceCommitmentResponse) Deref() {
	if x.ref4b00fda4 == nil {
		return
	}
	x.StatusCode = (FCPResponseStatus)(x.ref4b00fda4.status_code)
	x.ErrorMsg = packPCharString(x.ref4b00fda4.error_msg)
	x.CommP = *(*[32]byte)(unsafe.Pointer(&x.ref4b00fda4.comm_p))
	x.NumBytesAligned = (uint64)(x.ref4b00fda4.num_bytes_aligned)
}

// allocFilPoStProofMemory allocates memory for type C.fil_PoStProof in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilPoStProofMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilPoStProofValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFilPoStProofValue = unsafe.Sizeof([1]C.fil_PoStProof{})

// unpackPUint8TString represents the data from Go string as *C.uint8_t and avoids copying.
func unpackPUint8TString(str string) (*C.uint8_t, *cgoAllocMap) {
	str = safeString(str)
	h := (*stringHeader)(unsafe.Pointer(&str))
	return (*C.uint8_t)(h.Data), cgoAllocsUnknown
}

// packPUint8TString creates a Go string backed by *C.uint8_t and avoids copying.
func packPUint8TString(p *C.uint8_t) (raw string) {
	if p != nil && *p != 0 {
		h := (*stringHeader)(unsafe.Pointer(&raw))
		h.Data = unsafe.Pointer(p)
		for *p != 0 {
			p = (*C.uint8_t)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1)) // p++
		}
		h.Len = int(uintptr(unsafe.Pointer(p)) - uintptr(h.Data))
	}
	return
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilPoStProof) Ref() *C.fil_PoStProof {
	if x == nil {
		return nil
	}
	return x.ref3451bfa
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilPoStProof) Free() {
	if x != nil && x.allocs3451bfa != nil {
		x.allocs3451bfa.(*cgoAllocMap).Free()
		x.ref3451bfa = nil
	}
}

// NewFilPoStProofRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilPoStProofRef(ref unsafe.Pointer) *FilPoStProof {
	if ref == nil {
		return nil
	}
	obj := new(FilPoStProof)
	obj.ref3451bfa = (*C.fil_PoStProof)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilPoStProof) PassRef() (*C.fil_PoStProof, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref3451bfa != nil {
		return x.ref3451bfa, nil
	}
	mem3451bfa := allocFilPoStProofMemory(1)
	ref3451bfa := (*C.fil_PoStProof)(mem3451bfa)
	allocs3451bfa := new(cgoAllocMap)
	allocs3451bfa.Add(mem3451bfa)

	var cregistered_proof_allocs *cgoAllocMap
	ref3451bfa.registered_proof, cregistered_proof_allocs = (C.fil_RegisteredPoStProof)(x.RegisteredProof), cgoAllocsUnknown
	allocs3451bfa.Borrow(cregistered_proof_allocs)

	var cproof_len_allocs *cgoAllocMap
	ref3451bfa.proof_len, cproof_len_allocs = (C.size_t)(x.ProofLen), cgoAllocsUnknown
	allocs3451bfa.Borrow(cproof_len_allocs)

	var cproof_ptr_allocs *cgoAllocMap
	ref3451bfa.proof_ptr, cproof_ptr_allocs = unpackPUint8TString(x.ProofPtr)
	allocs3451bfa.Borrow(cproof_ptr_allocs)

	x.ref3451bfa = ref3451bfa
	x.allocs3451bfa = allocs3451bfa
	return ref3451bfa, allocs3451bfa

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilPoStProof) PassValue() (C.fil_PoStProof, *cgoAllocMap) {
	if x.ref3451bfa != nil {
		return *x.ref3451bfa, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilPoStProof) Deref() {
	if x.ref3451bfa == nil {
		return
	}
	x.RegisteredProof = (FilRegisteredPoStProof)(x.ref3451bfa.registered_proof)
	x.ProofLen = (uint)(x.ref3451bfa.proof_len)
	x.ProofPtr = packPUint8TString(x.ref3451bfa.proof_ptr)
}

// allocFilGeneratePoStResponseMemory allocates memory for type C.fil_GeneratePoStResponse in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilGeneratePoStResponseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilGeneratePoStResponseValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFilGeneratePoStResponseValue = unsafe.Sizeof([1]C.fil_GeneratePoStResponse{})

// unpackSFilPoStProof transforms a sliced Go data structure into plain C format.
func unpackSFilPoStProof(x []FilPoStProof) (unpacked *C.fil_PoStProof, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.fil_PoStProof) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocFilPoStProofMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.fil_PoStProof)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.fil_PoStProof)(h.Data)
	return
}

// packSFilPoStProof reads sliced Go data structure out from plain C format.
func packSFilPoStProof(v []FilPoStProof, ptr0 *C.fil_PoStProof) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfFilPoStProofValue]C.fil_PoStProof)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewFilPoStProofRef(unsafe.Pointer(&ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilGeneratePoStResponse) Ref() *C.fil_GeneratePoStResponse {
	if x == nil {
		return nil
	}
	return x.ref1a2ff84c
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilGeneratePoStResponse) Free() {
	if x != nil && x.allocs1a2ff84c != nil {
		x.allocs1a2ff84c.(*cgoAllocMap).Free()
		x.ref1a2ff84c = nil
	}
}

// NewFilGeneratePoStResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilGeneratePoStResponseRef(ref unsafe.Pointer) *FilGeneratePoStResponse {
	if ref == nil {
		return nil
	}
	obj := new(FilGeneratePoStResponse)
	obj.ref1a2ff84c = (*C.fil_GeneratePoStResponse)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilGeneratePoStResponse) PassRef() (*C.fil_GeneratePoStResponse, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref1a2ff84c != nil {
		return x.ref1a2ff84c, nil
	}
	mem1a2ff84c := allocFilGeneratePoStResponseMemory(1)
	ref1a2ff84c := (*C.fil_GeneratePoStResponse)(mem1a2ff84c)
	allocs1a2ff84c := new(cgoAllocMap)
	allocs1a2ff84c.Add(mem1a2ff84c)

	var cerror_msg_allocs *cgoAllocMap
	ref1a2ff84c.error_msg, cerror_msg_allocs = unpackPCharString(x.ErrorMsg)
	allocs1a2ff84c.Borrow(cerror_msg_allocs)

	var cproofs_len_allocs *cgoAllocMap
	ref1a2ff84c.proofs_len, cproofs_len_allocs = (C.size_t)(x.ProofsLen), cgoAllocsUnknown
	allocs1a2ff84c.Borrow(cproofs_len_allocs)

	var cproofs_ptr_allocs *cgoAllocMap
	ref1a2ff84c.proofs_ptr, cproofs_ptr_allocs = unpackSFilPoStProof(x.ProofsPtr)
	allocs1a2ff84c.Borrow(cproofs_ptr_allocs)

	var cstatus_code_allocs *cgoAllocMap
	ref1a2ff84c.status_code, cstatus_code_allocs = (C.FCPResponseStatus)(x.StatusCode), cgoAllocsUnknown
	allocs1a2ff84c.Borrow(cstatus_code_allocs)

	x.ref1a2ff84c = ref1a2ff84c
	x.allocs1a2ff84c = allocs1a2ff84c
	return ref1a2ff84c, allocs1a2ff84c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilGeneratePoStResponse) PassValue() (C.fil_GeneratePoStResponse, *cgoAllocMap) {
	if x.ref1a2ff84c != nil {
		return *x.ref1a2ff84c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilGeneratePoStResponse) Deref() {
	if x.ref1a2ff84c == nil {
		return
	}
	x.ErrorMsg = packPCharString(x.ref1a2ff84c.error_msg)
	x.ProofsLen = (uint)(x.ref1a2ff84c.proofs_len)
	packSFilPoStProof(x.ProofsPtr, x.ref1a2ff84c.proofs_ptr)
	x.StatusCode = (FCPResponseStatus)(x.ref1a2ff84c.status_code)
}

// allocFilGpuDeviceResponseMemory allocates memory for type C.fil_GpuDeviceResponse in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilGpuDeviceResponseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilGpuDeviceResponseValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFilGpuDeviceResponseValue = unsafe.Sizeof([1]C.fil_GpuDeviceResponse{})

// allocPCharMemory allocates memory for type *C.char in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPCharMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPCharValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPCharValue = unsafe.Sizeof([1]*C.char{})

// unpackSString transforms a sliced Go data structure into plain C format.
func unpackSString(x []string) (unpacked **C.char, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(***C.char) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPCharMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.char)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = unpackPCharString(x[i0])
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.char)(h.Data)
	return
}

// packSString reads sliced Go data structure out from plain C format.
func packSString(v []string, ptr0 **C.char) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.char)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = packPCharString(ptr1)
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilGpuDeviceResponse) Ref() *C.fil_GpuDeviceResponse {
	if x == nil {
		return nil
	}
	return x.ref58f92915
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilGpuDeviceResponse) Free() {
	if x != nil && x.allocs58f92915 != nil {
		x.allocs58f92915.(*cgoAllocMap).Free()
		x.ref58f92915 = nil
	}
}

// NewFilGpuDeviceResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilGpuDeviceResponseRef(ref unsafe.Pointer) *FilGpuDeviceResponse {
	if ref == nil {
		return nil
	}
	obj := new(FilGpuDeviceResponse)
	obj.ref58f92915 = (*C.fil_GpuDeviceResponse)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilGpuDeviceResponse) PassRef() (*C.fil_GpuDeviceResponse, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref58f92915 != nil {
		return x.ref58f92915, nil
	}
	mem58f92915 := allocFilGpuDeviceResponseMemory(1)
	ref58f92915 := (*C.fil_GpuDeviceResponse)(mem58f92915)
	allocs58f92915 := new(cgoAllocMap)
	allocs58f92915.Add(mem58f92915)

	var cstatus_code_allocs *cgoAllocMap
	ref58f92915.status_code, cstatus_code_allocs = (C.FCPResponseStatus)(x.StatusCode), cgoAllocsUnknown
	allocs58f92915.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	ref58f92915.error_msg, cerror_msg_allocs = unpackPCharString(x.ErrorMsg)
	allocs58f92915.Borrow(cerror_msg_allocs)

	var cdevices_len_allocs *cgoAllocMap
	ref58f92915.devices_len, cdevices_len_allocs = (C.size_t)(x.DevicesLen), cgoAllocsUnknown
	allocs58f92915.Borrow(cdevices_len_allocs)

	var cdevices_ptr_allocs *cgoAllocMap
	ref58f92915.devices_ptr, cdevices_ptr_allocs = unpackSString(x.DevicesPtr)
	allocs58f92915.Borrow(cdevices_ptr_allocs)

	x.ref58f92915 = ref58f92915
	x.allocs58f92915 = allocs58f92915
	return ref58f92915, allocs58f92915

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilGpuDeviceResponse) PassValue() (C.fil_GpuDeviceResponse, *cgoAllocMap) {
	if x.ref58f92915 != nil {
		return *x.ref58f92915, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilGpuDeviceResponse) Deref() {
	if x.ref58f92915 == nil {
		return
	}
	x.StatusCode = (FCPResponseStatus)(x.ref58f92915.status_code)
	x.ErrorMsg = packPCharString(x.ref58f92915.error_msg)
	x.DevicesLen = (uint)(x.ref58f92915.devices_len)
	packSString(x.DevicesPtr, x.ref58f92915.devices_ptr)
}

// allocFilBLSDigestMemory allocates memory for type C.fil_BLSDigest in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilBLSDigestMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilBLSDigestValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFilBLSDigestValue = unsafe.Sizeof([1]C.fil_BLSDigest{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilBLSDigest) Ref() *C.fil_BLSDigest {
	if x == nil {
		return nil
	}
	return x.ref215fc78c
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilBLSDigest) Free() {
	if x != nil && x.allocs215fc78c != nil {
		x.allocs215fc78c.(*cgoAllocMap).Free()
		x.ref215fc78c = nil
	}
}

// NewFilBLSDigestRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilBLSDigestRef(ref unsafe.Pointer) *FilBLSDigest {
	if ref == nil {
		return nil
	}
	obj := new(FilBLSDigest)
	obj.ref215fc78c = (*C.fil_BLSDigest)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilBLSDigest) PassRef() (*C.fil_BLSDigest, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref215fc78c != nil {
		return x.ref215fc78c, nil
	}
	mem215fc78c := allocFilBLSDigestMemory(1)
	ref215fc78c := (*C.fil_BLSDigest)(mem215fc78c)
	allocs215fc78c := new(cgoAllocMap)
	allocs215fc78c.Add(mem215fc78c)

	var cinner_allocs *cgoAllocMap
	ref215fc78c.inner, cinner_allocs = *(*[96]C.uint8_t)(unsafe.Pointer(&x.Inner)), cgoAllocsUnknown
	allocs215fc78c.Borrow(cinner_allocs)

	x.ref215fc78c = ref215fc78c
	x.allocs215fc78c = allocs215fc78c
	return ref215fc78c, allocs215fc78c

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilBLSDigest) PassValue() (C.fil_BLSDigest, *cgoAllocMap) {
	if x.ref215fc78c != nil {
		return *x.ref215fc78c, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilBLSDigest) Deref() {
	if x.ref215fc78c == nil {
		return
	}
	x.Inner = *(*[96]byte)(unsafe.Pointer(&x.ref215fc78c.inner))
}

// allocFilHashResponseMemory allocates memory for type C.fil_HashResponse in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilHashResponseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilHashResponseValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFilHashResponseValue = unsafe.Sizeof([1]C.fil_HashResponse{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilHashResponse) Ref() *C.fil_HashResponse {
	if x == nil {
		return nil
	}
	return x.refc52a22ef
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilHashResponse) Free() {
	if x != nil && x.allocsc52a22ef != nil {
		x.allocsc52a22ef.(*cgoAllocMap).Free()
		x.refc52a22ef = nil
	}
}

// NewFilHashResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilHashResponseRef(ref unsafe.Pointer) *FilHashResponse {
	if ref == nil {
		return nil
	}
	obj := new(FilHashResponse)
	obj.refc52a22ef = (*C.fil_HashResponse)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilHashResponse) PassRef() (*C.fil_HashResponse, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc52a22ef != nil {
		return x.refc52a22ef, nil
	}
	memc52a22ef := allocFilHashResponseMemory(1)
	refc52a22ef := (*C.fil_HashResponse)(memc52a22ef)
	allocsc52a22ef := new(cgoAllocMap)
	allocsc52a22ef.Add(memc52a22ef)

	var cdigest_allocs *cgoAllocMap
	refc52a22ef.digest, cdigest_allocs = x.Digest.PassValue()
	allocsc52a22ef.Borrow(cdigest_allocs)

	x.refc52a22ef = refc52a22ef
	x.allocsc52a22ef = allocsc52a22ef
	return refc52a22ef, allocsc52a22ef

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilHashResponse) PassValue() (C.fil_HashResponse, *cgoAllocMap) {
	if x.refc52a22ef != nil {
		return *x.refc52a22ef, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilHashResponse) Deref() {
	if x.refc52a22ef == nil {
		return
	}
	x.Digest = *NewFilBLSDigestRef(unsafe.Pointer(&x.refc52a22ef.digest))
}

// allocFilBLSPrivateKeyMemory allocates memory for type C.fil_BLSPrivateKey in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilBLSPrivateKeyMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilBLSPrivateKeyValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFilBLSPrivateKeyValue = unsafe.Sizeof([1]C.fil_BLSPrivateKey{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilBLSPrivateKey) Ref() *C.fil_BLSPrivateKey {
	if x == nil {
		return nil
	}
	return x.ref2f77fe3a
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilBLSPrivateKey) Free() {
	if x != nil && x.allocs2f77fe3a != nil {
		x.allocs2f77fe3a.(*cgoAllocMap).Free()
		x.ref2f77fe3a = nil
	}
}

// NewFilBLSPrivateKeyRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilBLSPrivateKeyRef(ref unsafe.Pointer) *FilBLSPrivateKey {
	if ref == nil {
		return nil
	}
	obj := new(FilBLSPrivateKey)
	obj.ref2f77fe3a = (*C.fil_BLSPrivateKey)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilBLSPrivateKey) PassRef() (*C.fil_BLSPrivateKey, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2f77fe3a != nil {
		return x.ref2f77fe3a, nil
	}
	mem2f77fe3a := allocFilBLSPrivateKeyMemory(1)
	ref2f77fe3a := (*C.fil_BLSPrivateKey)(mem2f77fe3a)
	allocs2f77fe3a := new(cgoAllocMap)
	allocs2f77fe3a.Add(mem2f77fe3a)

	var cinner_allocs *cgoAllocMap
	ref2f77fe3a.inner, cinner_allocs = *(*[32]C.uint8_t)(unsafe.Pointer(&x.Inner)), cgoAllocsUnknown
	allocs2f77fe3a.Borrow(cinner_allocs)

	x.ref2f77fe3a = ref2f77fe3a
	x.allocs2f77fe3a = allocs2f77fe3a
	return ref2f77fe3a, allocs2f77fe3a

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilBLSPrivateKey) PassValue() (C.fil_BLSPrivateKey, *cgoAllocMap) {
	if x.ref2f77fe3a != nil {
		return *x.ref2f77fe3a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilBLSPrivateKey) Deref() {
	if x.ref2f77fe3a == nil {
		return
	}
	x.Inner = *(*[32]byte)(unsafe.Pointer(&x.ref2f77fe3a.inner))
}

// allocFilPrivateKeyGenerateResponseMemory allocates memory for type C.fil_PrivateKeyGenerateResponse in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilPrivateKeyGenerateResponseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilPrivateKeyGenerateResponseValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFilPrivateKeyGenerateResponseValue = unsafe.Sizeof([1]C.fil_PrivateKeyGenerateResponse{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilPrivateKeyGenerateResponse) Ref() *C.fil_PrivateKeyGenerateResponse {
	if x == nil {
		return nil
	}
	return x.ref2dba09f
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilPrivateKeyGenerateResponse) Free() {
	if x != nil && x.allocs2dba09f != nil {
		x.allocs2dba09f.(*cgoAllocMap).Free()
		x.ref2dba09f = nil
	}
}

// NewFilPrivateKeyGenerateResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilPrivateKeyGenerateResponseRef(ref unsafe.Pointer) *FilPrivateKeyGenerateResponse {
	if ref == nil {
		return nil
	}
	obj := new(FilPrivateKeyGenerateResponse)
	obj.ref2dba09f = (*C.fil_PrivateKeyGenerateResponse)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilPrivateKeyGenerateResponse) PassRef() (*C.fil_PrivateKeyGenerateResponse, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2dba09f != nil {
		return x.ref2dba09f, nil
	}
	mem2dba09f := allocFilPrivateKeyGenerateResponseMemory(1)
	ref2dba09f := (*C.fil_PrivateKeyGenerateResponse)(mem2dba09f)
	allocs2dba09f := new(cgoAllocMap)
	allocs2dba09f.Add(mem2dba09f)

	var cprivate_key_allocs *cgoAllocMap
	ref2dba09f.private_key, cprivate_key_allocs = x.PrivateKey.PassValue()
	allocs2dba09f.Borrow(cprivate_key_allocs)

	x.ref2dba09f = ref2dba09f
	x.allocs2dba09f = allocs2dba09f
	return ref2dba09f, allocs2dba09f

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilPrivateKeyGenerateResponse) PassValue() (C.fil_PrivateKeyGenerateResponse, *cgoAllocMap) {
	if x.ref2dba09f != nil {
		return *x.ref2dba09f, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilPrivateKeyGenerateResponse) Deref() {
	if x.ref2dba09f == nil {
		return
	}
	x.PrivateKey = *NewFilBLSPrivateKeyRef(unsafe.Pointer(&x.ref2dba09f.private_key))
}

// allocFilBLSPublicKeyMemory allocates memory for type C.fil_BLSPublicKey in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilBLSPublicKeyMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilBLSPublicKeyValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFilBLSPublicKeyValue = unsafe.Sizeof([1]C.fil_BLSPublicKey{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilBLSPublicKey) Ref() *C.fil_BLSPublicKey {
	if x == nil {
		return nil
	}
	return x.ref6d0cab13
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilBLSPublicKey) Free() {
	if x != nil && x.allocs6d0cab13 != nil {
		x.allocs6d0cab13.(*cgoAllocMap).Free()
		x.ref6d0cab13 = nil
	}
}

// NewFilBLSPublicKeyRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilBLSPublicKeyRef(ref unsafe.Pointer) *FilBLSPublicKey {
	if ref == nil {
		return nil
	}
	obj := new(FilBLSPublicKey)
	obj.ref6d0cab13 = (*C.fil_BLSPublicKey)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilBLSPublicKey) PassRef() (*C.fil_BLSPublicKey, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref6d0cab13 != nil {
		return x.ref6d0cab13, nil
	}
	mem6d0cab13 := allocFilBLSPublicKeyMemory(1)
	ref6d0cab13 := (*C.fil_BLSPublicKey)(mem6d0cab13)
	allocs6d0cab13 := new(cgoAllocMap)
	allocs6d0cab13.Add(mem6d0cab13)

	var cinner_allocs *cgoAllocMap
	ref6d0cab13.inner, cinner_allocs = *(*[48]C.uint8_t)(unsafe.Pointer(&x.Inner)), cgoAllocsUnknown
	allocs6d0cab13.Borrow(cinner_allocs)

	x.ref6d0cab13 = ref6d0cab13
	x.allocs6d0cab13 = allocs6d0cab13
	return ref6d0cab13, allocs6d0cab13

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilBLSPublicKey) PassValue() (C.fil_BLSPublicKey, *cgoAllocMap) {
	if x.ref6d0cab13 != nil {
		return *x.ref6d0cab13, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilBLSPublicKey) Deref() {
	if x.ref6d0cab13 == nil {
		return
	}
	x.Inner = *(*[48]byte)(unsafe.Pointer(&x.ref6d0cab13.inner))
}

// allocFilPrivateKeyPublicKeyResponseMemory allocates memory for type C.fil_PrivateKeyPublicKeyResponse in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilPrivateKeyPublicKeyResponseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilPrivateKeyPublicKeyResponseValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFilPrivateKeyPublicKeyResponseValue = unsafe.Sizeof([1]C.fil_PrivateKeyPublicKeyResponse{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilPrivateKeyPublicKeyResponse) Ref() *C.fil_PrivateKeyPublicKeyResponse {
	if x == nil {
		return nil
	}
	return x.refee14e59d
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilPrivateKeyPublicKeyResponse) Free() {
	if x != nil && x.allocsee14e59d != nil {
		x.allocsee14e59d.(*cgoAllocMap).Free()
		x.refee14e59d = nil
	}
}

// NewFilPrivateKeyPublicKeyResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilPrivateKeyPublicKeyResponseRef(ref unsafe.Pointer) *FilPrivateKeyPublicKeyResponse {
	if ref == nil {
		return nil
	}
	obj := new(FilPrivateKeyPublicKeyResponse)
	obj.refee14e59d = (*C.fil_PrivateKeyPublicKeyResponse)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilPrivateKeyPublicKeyResponse) PassRef() (*C.fil_PrivateKeyPublicKeyResponse, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refee14e59d != nil {
		return x.refee14e59d, nil
	}
	memee14e59d := allocFilPrivateKeyPublicKeyResponseMemory(1)
	refee14e59d := (*C.fil_PrivateKeyPublicKeyResponse)(memee14e59d)
	allocsee14e59d := new(cgoAllocMap)
	allocsee14e59d.Add(memee14e59d)

	var cpublic_key_allocs *cgoAllocMap
	refee14e59d.public_key, cpublic_key_allocs = x.PublicKey.PassValue()
	allocsee14e59d.Borrow(cpublic_key_allocs)

	x.refee14e59d = refee14e59d
	x.allocsee14e59d = allocsee14e59d
	return refee14e59d, allocsee14e59d

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilPrivateKeyPublicKeyResponse) PassValue() (C.fil_PrivateKeyPublicKeyResponse, *cgoAllocMap) {
	if x.refee14e59d != nil {
		return *x.refee14e59d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilPrivateKeyPublicKeyResponse) Deref() {
	if x.refee14e59d == nil {
		return
	}
	x.PublicKey = *NewFilBLSPublicKeyRef(unsafe.Pointer(&x.refee14e59d.public_key))
}

// allocFilPrivateKeySignResponseMemory allocates memory for type C.fil_PrivateKeySignResponse in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilPrivateKeySignResponseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilPrivateKeySignResponseValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFilPrivateKeySignResponseValue = unsafe.Sizeof([1]C.fil_PrivateKeySignResponse{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilPrivateKeySignResponse) Ref() *C.fil_PrivateKeySignResponse {
	if x == nil {
		return nil
	}
	return x.refcdf97b28
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilPrivateKeySignResponse) Free() {
	if x != nil && x.allocscdf97b28 != nil {
		x.allocscdf97b28.(*cgoAllocMap).Free()
		x.refcdf97b28 = nil
	}
}

// NewFilPrivateKeySignResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilPrivateKeySignResponseRef(ref unsafe.Pointer) *FilPrivateKeySignResponse {
	if ref == nil {
		return nil
	}
	obj := new(FilPrivateKeySignResponse)
	obj.refcdf97b28 = (*C.fil_PrivateKeySignResponse)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilPrivateKeySignResponse) PassRef() (*C.fil_PrivateKeySignResponse, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refcdf97b28 != nil {
		return x.refcdf97b28, nil
	}
	memcdf97b28 := allocFilPrivateKeySignResponseMemory(1)
	refcdf97b28 := (*C.fil_PrivateKeySignResponse)(memcdf97b28)
	allocscdf97b28 := new(cgoAllocMap)
	allocscdf97b28.Add(memcdf97b28)

	var csignature_allocs *cgoAllocMap
	refcdf97b28.signature, csignature_allocs = x.Signature.PassValue()
	allocscdf97b28.Borrow(csignature_allocs)

	x.refcdf97b28 = refcdf97b28
	x.allocscdf97b28 = allocscdf97b28
	return refcdf97b28, allocscdf97b28

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilPrivateKeySignResponse) PassValue() (C.fil_PrivateKeySignResponse, *cgoAllocMap) {
	if x.refcdf97b28 != nil {
		return *x.refcdf97b28, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilPrivateKeySignResponse) Deref() {
	if x.refcdf97b28 == nil {
		return
	}
	x.Signature = *NewFilBLSSignatureRef(unsafe.Pointer(&x.refcdf97b28.signature))
}

// allocFilSealCommitPhase1ResponseMemory allocates memory for type C.fil_SealCommitPhase1Response in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilSealCommitPhase1ResponseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilSealCommitPhase1ResponseValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFilSealCommitPhase1ResponseValue = unsafe.Sizeof([1]C.fil_SealCommitPhase1Response{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilSealCommitPhase1Response) Ref() *C.fil_SealCommitPhase1Response {
	if x == nil {
		return nil
	}
	return x.ref61ed8561
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilSealCommitPhase1Response) Free() {
	if x != nil && x.allocs61ed8561 != nil {
		x.allocs61ed8561.(*cgoAllocMap).Free()
		x.ref61ed8561 = nil
	}
}

// NewFilSealCommitPhase1ResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilSealCommitPhase1ResponseRef(ref unsafe.Pointer) *FilSealCommitPhase1Response {
	if ref == nil {
		return nil
	}
	obj := new(FilSealCommitPhase1Response)
	obj.ref61ed8561 = (*C.fil_SealCommitPhase1Response)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilSealCommitPhase1Response) PassRef() (*C.fil_SealCommitPhase1Response, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref61ed8561 != nil {
		return x.ref61ed8561, nil
	}
	mem61ed8561 := allocFilSealCommitPhase1ResponseMemory(1)
	ref61ed8561 := (*C.fil_SealCommitPhase1Response)(mem61ed8561)
	allocs61ed8561 := new(cgoAllocMap)
	allocs61ed8561.Add(mem61ed8561)

	var cstatus_code_allocs *cgoAllocMap
	ref61ed8561.status_code, cstatus_code_allocs = (C.FCPResponseStatus)(x.StatusCode), cgoAllocsUnknown
	allocs61ed8561.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	ref61ed8561.error_msg, cerror_msg_allocs = unpackPCharString(x.ErrorMsg)
	allocs61ed8561.Borrow(cerror_msg_allocs)

	var cseal_commit_phase1_output_ptr_allocs *cgoAllocMap
	ref61ed8561.seal_commit_phase1_output_ptr, cseal_commit_phase1_output_ptr_allocs = unpackPUint8TString(x.SealCommitPhase1OutputPtr)
	allocs61ed8561.Borrow(cseal_commit_phase1_output_ptr_allocs)

	var cseal_commit_phase1_output_len_allocs *cgoAllocMap
	ref61ed8561.seal_commit_phase1_output_len, cseal_commit_phase1_output_len_allocs = (C.size_t)(x.SealCommitPhase1OutputLen), cgoAllocsUnknown
	allocs61ed8561.Borrow(cseal_commit_phase1_output_len_allocs)

	x.ref61ed8561 = ref61ed8561
	x.allocs61ed8561 = allocs61ed8561
	return ref61ed8561, allocs61ed8561

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilSealCommitPhase1Response) PassValue() (C.fil_SealCommitPhase1Response, *cgoAllocMap) {
	if x.ref61ed8561 != nil {
		return *x.ref61ed8561, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilSealCommitPhase1Response) Deref() {
	if x.ref61ed8561 == nil {
		return
	}
	x.StatusCode = (FCPResponseStatus)(x.ref61ed8561.status_code)
	x.ErrorMsg = packPCharString(x.ref61ed8561.error_msg)
	x.SealCommitPhase1OutputPtr = packPUint8TString(x.ref61ed8561.seal_commit_phase1_output_ptr)
	x.SealCommitPhase1OutputLen = (uint)(x.ref61ed8561.seal_commit_phase1_output_len)
}

// allocFilSealCommitPhase2ResponseMemory allocates memory for type C.fil_SealCommitPhase2Response in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilSealCommitPhase2ResponseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilSealCommitPhase2ResponseValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFilSealCommitPhase2ResponseValue = unsafe.Sizeof([1]C.fil_SealCommitPhase2Response{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilSealCommitPhase2Response) Ref() *C.fil_SealCommitPhase2Response {
	if x == nil {
		return nil
	}
	return x.ref5860b9a4
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilSealCommitPhase2Response) Free() {
	if x != nil && x.allocs5860b9a4 != nil {
		x.allocs5860b9a4.(*cgoAllocMap).Free()
		x.ref5860b9a4 = nil
	}
}

// NewFilSealCommitPhase2ResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilSealCommitPhase2ResponseRef(ref unsafe.Pointer) *FilSealCommitPhase2Response {
	if ref == nil {
		return nil
	}
	obj := new(FilSealCommitPhase2Response)
	obj.ref5860b9a4 = (*C.fil_SealCommitPhase2Response)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilSealCommitPhase2Response) PassRef() (*C.fil_SealCommitPhase2Response, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5860b9a4 != nil {
		return x.ref5860b9a4, nil
	}
	mem5860b9a4 := allocFilSealCommitPhase2ResponseMemory(1)
	ref5860b9a4 := (*C.fil_SealCommitPhase2Response)(mem5860b9a4)
	allocs5860b9a4 := new(cgoAllocMap)
	allocs5860b9a4.Add(mem5860b9a4)

	var cstatus_code_allocs *cgoAllocMap
	ref5860b9a4.status_code, cstatus_code_allocs = (C.FCPResponseStatus)(x.StatusCode), cgoAllocsUnknown
	allocs5860b9a4.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	ref5860b9a4.error_msg, cerror_msg_allocs = unpackPCharString(x.ErrorMsg)
	allocs5860b9a4.Borrow(cerror_msg_allocs)

	var cproof_ptr_allocs *cgoAllocMap
	ref5860b9a4.proof_ptr, cproof_ptr_allocs = unpackPUint8TString(x.ProofPtr)
	allocs5860b9a4.Borrow(cproof_ptr_allocs)

	var cproof_len_allocs *cgoAllocMap
	ref5860b9a4.proof_len, cproof_len_allocs = (C.size_t)(x.ProofLen), cgoAllocsUnknown
	allocs5860b9a4.Borrow(cproof_len_allocs)

	x.ref5860b9a4 = ref5860b9a4
	x.allocs5860b9a4 = allocs5860b9a4
	return ref5860b9a4, allocs5860b9a4

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilSealCommitPhase2Response) PassValue() (C.fil_SealCommitPhase2Response, *cgoAllocMap) {
	if x.ref5860b9a4 != nil {
		return *x.ref5860b9a4, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilSealCommitPhase2Response) Deref() {
	if x.ref5860b9a4 == nil {
		return
	}
	x.StatusCode = (FCPResponseStatus)(x.ref5860b9a4.status_code)
	x.ErrorMsg = packPCharString(x.ref5860b9a4.error_msg)
	x.ProofPtr = packPUint8TString(x.ref5860b9a4.proof_ptr)
	x.ProofLen = (uint)(x.ref5860b9a4.proof_len)
}

// allocFilSealPreCommitPhase1ResponseMemory allocates memory for type C.fil_SealPreCommitPhase1Response in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilSealPreCommitPhase1ResponseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilSealPreCommitPhase1ResponseValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFilSealPreCommitPhase1ResponseValue = unsafe.Sizeof([1]C.fil_SealPreCommitPhase1Response{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilSealPreCommitPhase1Response) Ref() *C.fil_SealPreCommitPhase1Response {
	if x == nil {
		return nil
	}
	return x.ref132bbfd8
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilSealPreCommitPhase1Response) Free() {
	if x != nil && x.allocs132bbfd8 != nil {
		x.allocs132bbfd8.(*cgoAllocMap).Free()
		x.ref132bbfd8 = nil
	}
}

// NewFilSealPreCommitPhase1ResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilSealPreCommitPhase1ResponseRef(ref unsafe.Pointer) *FilSealPreCommitPhase1Response {
	if ref == nil {
		return nil
	}
	obj := new(FilSealPreCommitPhase1Response)
	obj.ref132bbfd8 = (*C.fil_SealPreCommitPhase1Response)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilSealPreCommitPhase1Response) PassRef() (*C.fil_SealPreCommitPhase1Response, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref132bbfd8 != nil {
		return x.ref132bbfd8, nil
	}
	mem132bbfd8 := allocFilSealPreCommitPhase1ResponseMemory(1)
	ref132bbfd8 := (*C.fil_SealPreCommitPhase1Response)(mem132bbfd8)
	allocs132bbfd8 := new(cgoAllocMap)
	allocs132bbfd8.Add(mem132bbfd8)

	var cerror_msg_allocs *cgoAllocMap
	ref132bbfd8.error_msg, cerror_msg_allocs = unpackPCharString(x.ErrorMsg)
	allocs132bbfd8.Borrow(cerror_msg_allocs)

	var cstatus_code_allocs *cgoAllocMap
	ref132bbfd8.status_code, cstatus_code_allocs = (C.FCPResponseStatus)(x.StatusCode), cgoAllocsUnknown
	allocs132bbfd8.Borrow(cstatus_code_allocs)

	var cseal_pre_commit_phase1_output_ptr_allocs *cgoAllocMap
	ref132bbfd8.seal_pre_commit_phase1_output_ptr, cseal_pre_commit_phase1_output_ptr_allocs = unpackPUint8TString(x.SealPreCommitPhase1OutputPtr)
	allocs132bbfd8.Borrow(cseal_pre_commit_phase1_output_ptr_allocs)

	var cseal_pre_commit_phase1_output_len_allocs *cgoAllocMap
	ref132bbfd8.seal_pre_commit_phase1_output_len, cseal_pre_commit_phase1_output_len_allocs = (C.size_t)(x.SealPreCommitPhase1OutputLen), cgoAllocsUnknown
	allocs132bbfd8.Borrow(cseal_pre_commit_phase1_output_len_allocs)

	x.ref132bbfd8 = ref132bbfd8
	x.allocs132bbfd8 = allocs132bbfd8
	return ref132bbfd8, allocs132bbfd8

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilSealPreCommitPhase1Response) PassValue() (C.fil_SealPreCommitPhase1Response, *cgoAllocMap) {
	if x.ref132bbfd8 != nil {
		return *x.ref132bbfd8, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilSealPreCommitPhase1Response) Deref() {
	if x.ref132bbfd8 == nil {
		return
	}
	x.ErrorMsg = packPCharString(x.ref132bbfd8.error_msg)
	x.StatusCode = (FCPResponseStatus)(x.ref132bbfd8.status_code)
	x.SealPreCommitPhase1OutputPtr = packPUint8TString(x.ref132bbfd8.seal_pre_commit_phase1_output_ptr)
	x.SealPreCommitPhase1OutputLen = (uint)(x.ref132bbfd8.seal_pre_commit_phase1_output_len)
}

// allocFilSealPreCommitPhase2ResponseMemory allocates memory for type C.fil_SealPreCommitPhase2Response in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilSealPreCommitPhase2ResponseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilSealPreCommitPhase2ResponseValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFilSealPreCommitPhase2ResponseValue = unsafe.Sizeof([1]C.fil_SealPreCommitPhase2Response{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilSealPreCommitPhase2Response) Ref() *C.fil_SealPreCommitPhase2Response {
	if x == nil {
		return nil
	}
	return x.ref2aa6831d
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilSealPreCommitPhase2Response) Free() {
	if x != nil && x.allocs2aa6831d != nil {
		x.allocs2aa6831d.(*cgoAllocMap).Free()
		x.ref2aa6831d = nil
	}
}

// NewFilSealPreCommitPhase2ResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilSealPreCommitPhase2ResponseRef(ref unsafe.Pointer) *FilSealPreCommitPhase2Response {
	if ref == nil {
		return nil
	}
	obj := new(FilSealPreCommitPhase2Response)
	obj.ref2aa6831d = (*C.fil_SealPreCommitPhase2Response)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilSealPreCommitPhase2Response) PassRef() (*C.fil_SealPreCommitPhase2Response, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2aa6831d != nil {
		return x.ref2aa6831d, nil
	}
	mem2aa6831d := allocFilSealPreCommitPhase2ResponseMemory(1)
	ref2aa6831d := (*C.fil_SealPreCommitPhase2Response)(mem2aa6831d)
	allocs2aa6831d := new(cgoAllocMap)
	allocs2aa6831d.Add(mem2aa6831d)

	var cerror_msg_allocs *cgoAllocMap
	ref2aa6831d.error_msg, cerror_msg_allocs = unpackPCharString(x.ErrorMsg)
	allocs2aa6831d.Borrow(cerror_msg_allocs)

	var cstatus_code_allocs *cgoAllocMap
	ref2aa6831d.status_code, cstatus_code_allocs = (C.FCPResponseStatus)(x.StatusCode), cgoAllocsUnknown
	allocs2aa6831d.Borrow(cstatus_code_allocs)

	var cregistered_proof_allocs *cgoAllocMap
	ref2aa6831d.registered_proof, cregistered_proof_allocs = (C.fil_RegisteredSealProof)(x.RegisteredProof), cgoAllocsUnknown
	allocs2aa6831d.Borrow(cregistered_proof_allocs)

	var ccomm_d_allocs *cgoAllocMap
	ref2aa6831d.comm_d, ccomm_d_allocs = *(*[32]C.uint8_t)(unsafe.Pointer(&x.CommD)), cgoAllocsUnknown
	allocs2aa6831d.Borrow(ccomm_d_allocs)

	var ccomm_r_allocs *cgoAllocMap
	ref2aa6831d.comm_r, ccomm_r_allocs = *(*[32]C.uint8_t)(unsafe.Pointer(&x.CommR)), cgoAllocsUnknown
	allocs2aa6831d.Borrow(ccomm_r_allocs)

	x.ref2aa6831d = ref2aa6831d
	x.allocs2aa6831d = allocs2aa6831d
	return ref2aa6831d, allocs2aa6831d

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilSealPreCommitPhase2Response) PassValue() (C.fil_SealPreCommitPhase2Response, *cgoAllocMap) {
	if x.ref2aa6831d != nil {
		return *x.ref2aa6831d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilSealPreCommitPhase2Response) Deref() {
	if x.ref2aa6831d == nil {
		return
	}
	x.ErrorMsg = packPCharString(x.ref2aa6831d.error_msg)
	x.StatusCode = (FCPResponseStatus)(x.ref2aa6831d.status_code)
	x.RegisteredProof = (FilRegisteredSealProof)(x.ref2aa6831d.registered_proof)
	x.CommD = *(*[32]byte)(unsafe.Pointer(&x.ref2aa6831d.comm_d))
	x.CommR = *(*[32]byte)(unsafe.Pointer(&x.ref2aa6831d.comm_r))
}

// allocFilStringResponseMemory allocates memory for type C.fil_StringResponse in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilStringResponseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilStringResponseValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFilStringResponseValue = unsafe.Sizeof([1]C.fil_StringResponse{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilStringResponse) Ref() *C.fil_StringResponse {
	if x == nil {
		return nil
	}
	return x.ref4f413043
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilStringResponse) Free() {
	if x != nil && x.allocs4f413043 != nil {
		x.allocs4f413043.(*cgoAllocMap).Free()
		x.ref4f413043 = nil
	}
}

// NewFilStringResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilStringResponseRef(ref unsafe.Pointer) *FilStringResponse {
	if ref == nil {
		return nil
	}
	obj := new(FilStringResponse)
	obj.ref4f413043 = (*C.fil_StringResponse)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilStringResponse) PassRef() (*C.fil_StringResponse, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref4f413043 != nil {
		return x.ref4f413043, nil
	}
	mem4f413043 := allocFilStringResponseMemory(1)
	ref4f413043 := (*C.fil_StringResponse)(mem4f413043)
	allocs4f413043 := new(cgoAllocMap)
	allocs4f413043.Add(mem4f413043)

	var cstatus_code_allocs *cgoAllocMap
	ref4f413043.status_code, cstatus_code_allocs = (C.FCPResponseStatus)(x.StatusCode), cgoAllocsUnknown
	allocs4f413043.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	ref4f413043.error_msg, cerror_msg_allocs = unpackPCharString(x.ErrorMsg)
	allocs4f413043.Borrow(cerror_msg_allocs)

	var cstring_val_allocs *cgoAllocMap
	ref4f413043.string_val, cstring_val_allocs = unpackPCharString(x.StringVal)
	allocs4f413043.Borrow(cstring_val_allocs)

	x.ref4f413043 = ref4f413043
	x.allocs4f413043 = allocs4f413043
	return ref4f413043, allocs4f413043

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilStringResponse) PassValue() (C.fil_StringResponse, *cgoAllocMap) {
	if x.ref4f413043 != nil {
		return *x.ref4f413043, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilStringResponse) Deref() {
	if x.ref4f413043 == nil {
		return
	}
	x.StatusCode = (FCPResponseStatus)(x.ref4f413043.status_code)
	x.ErrorMsg = packPCharString(x.ref4f413043.error_msg)
	x.StringVal = packPCharString(x.ref4f413043.string_val)
}

// allocFilUnsealRangeResponseMemory allocates memory for type C.fil_UnsealRangeResponse in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilUnsealRangeResponseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilUnsealRangeResponseValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFilUnsealRangeResponseValue = unsafe.Sizeof([1]C.fil_UnsealRangeResponse{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilUnsealRangeResponse) Ref() *C.fil_UnsealRangeResponse {
	if x == nil {
		return nil
	}
	return x.ref61e219c9
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilUnsealRangeResponse) Free() {
	if x != nil && x.allocs61e219c9 != nil {
		x.allocs61e219c9.(*cgoAllocMap).Free()
		x.ref61e219c9 = nil
	}
}

// NewFilUnsealRangeResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilUnsealRangeResponseRef(ref unsafe.Pointer) *FilUnsealRangeResponse {
	if ref == nil {
		return nil
	}
	obj := new(FilUnsealRangeResponse)
	obj.ref61e219c9 = (*C.fil_UnsealRangeResponse)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilUnsealRangeResponse) PassRef() (*C.fil_UnsealRangeResponse, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref61e219c9 != nil {
		return x.ref61e219c9, nil
	}
	mem61e219c9 := allocFilUnsealRangeResponseMemory(1)
	ref61e219c9 := (*C.fil_UnsealRangeResponse)(mem61e219c9)
	allocs61e219c9 := new(cgoAllocMap)
	allocs61e219c9.Add(mem61e219c9)

	var cstatus_code_allocs *cgoAllocMap
	ref61e219c9.status_code, cstatus_code_allocs = (C.FCPResponseStatus)(x.StatusCode), cgoAllocsUnknown
	allocs61e219c9.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	ref61e219c9.error_msg, cerror_msg_allocs = unpackPCharString(x.ErrorMsg)
	allocs61e219c9.Borrow(cerror_msg_allocs)

	x.ref61e219c9 = ref61e219c9
	x.allocs61e219c9 = allocs61e219c9
	return ref61e219c9, allocs61e219c9

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilUnsealRangeResponse) PassValue() (C.fil_UnsealRangeResponse, *cgoAllocMap) {
	if x.ref61e219c9 != nil {
		return *x.ref61e219c9, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilUnsealRangeResponse) Deref() {
	if x.ref61e219c9 == nil {
		return
	}
	x.StatusCode = (FCPResponseStatus)(x.ref61e219c9.status_code)
	x.ErrorMsg = packPCharString(x.ref61e219c9.error_msg)
}

// allocFilUnsealResponseMemory allocates memory for type C.fil_UnsealResponse in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilUnsealResponseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilUnsealResponseValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFilUnsealResponseValue = unsafe.Sizeof([1]C.fil_UnsealResponse{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilUnsealResponse) Ref() *C.fil_UnsealResponse {
	if x == nil {
		return nil
	}
	return x.refdb3aa0f1
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilUnsealResponse) Free() {
	if x != nil && x.allocsdb3aa0f1 != nil {
		x.allocsdb3aa0f1.(*cgoAllocMap).Free()
		x.refdb3aa0f1 = nil
	}
}

// NewFilUnsealResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilUnsealResponseRef(ref unsafe.Pointer) *FilUnsealResponse {
	if ref == nil {
		return nil
	}
	obj := new(FilUnsealResponse)
	obj.refdb3aa0f1 = (*C.fil_UnsealResponse)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilUnsealResponse) PassRef() (*C.fil_UnsealResponse, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refdb3aa0f1 != nil {
		return x.refdb3aa0f1, nil
	}
	memdb3aa0f1 := allocFilUnsealResponseMemory(1)
	refdb3aa0f1 := (*C.fil_UnsealResponse)(memdb3aa0f1)
	allocsdb3aa0f1 := new(cgoAllocMap)
	allocsdb3aa0f1.Add(memdb3aa0f1)

	var cstatus_code_allocs *cgoAllocMap
	refdb3aa0f1.status_code, cstatus_code_allocs = (C.FCPResponseStatus)(x.StatusCode), cgoAllocsUnknown
	allocsdb3aa0f1.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	refdb3aa0f1.error_msg, cerror_msg_allocs = unpackPCharString(x.ErrorMsg)
	allocsdb3aa0f1.Borrow(cerror_msg_allocs)

	x.refdb3aa0f1 = refdb3aa0f1
	x.allocsdb3aa0f1 = allocsdb3aa0f1
	return refdb3aa0f1, allocsdb3aa0f1

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilUnsealResponse) PassValue() (C.fil_UnsealResponse, *cgoAllocMap) {
	if x.refdb3aa0f1 != nil {
		return *x.refdb3aa0f1, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilUnsealResponse) Deref() {
	if x.refdb3aa0f1 == nil {
		return
	}
	x.StatusCode = (FCPResponseStatus)(x.refdb3aa0f1.status_code)
	x.ErrorMsg = packPCharString(x.refdb3aa0f1.error_msg)
}

// allocFilVerifyPoStResponseMemory allocates memory for type C.fil_VerifyPoStResponse in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilVerifyPoStResponseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilVerifyPoStResponseValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFilVerifyPoStResponseValue = unsafe.Sizeof([1]C.fil_VerifyPoStResponse{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilVerifyPoStResponse) Ref() *C.fil_VerifyPoStResponse {
	if x == nil {
		return nil
	}
	return x.ref3a164861
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilVerifyPoStResponse) Free() {
	if x != nil && x.allocs3a164861 != nil {
		x.allocs3a164861.(*cgoAllocMap).Free()
		x.ref3a164861 = nil
	}
}

// NewFilVerifyPoStResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilVerifyPoStResponseRef(ref unsafe.Pointer) *FilVerifyPoStResponse {
	if ref == nil {
		return nil
	}
	obj := new(FilVerifyPoStResponse)
	obj.ref3a164861 = (*C.fil_VerifyPoStResponse)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilVerifyPoStResponse) PassRef() (*C.fil_VerifyPoStResponse, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref3a164861 != nil {
		return x.ref3a164861, nil
	}
	mem3a164861 := allocFilVerifyPoStResponseMemory(1)
	ref3a164861 := (*C.fil_VerifyPoStResponse)(mem3a164861)
	allocs3a164861 := new(cgoAllocMap)
	allocs3a164861.Add(mem3a164861)

	var cstatus_code_allocs *cgoAllocMap
	ref3a164861.status_code, cstatus_code_allocs = (C.FCPResponseStatus)(x.StatusCode), cgoAllocsUnknown
	allocs3a164861.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	ref3a164861.error_msg, cerror_msg_allocs = unpackPCharString(x.ErrorMsg)
	allocs3a164861.Borrow(cerror_msg_allocs)

	var cis_valid_allocs *cgoAllocMap
	ref3a164861.is_valid, cis_valid_allocs = (C._Bool)(x.IsValid), cgoAllocsUnknown
	allocs3a164861.Borrow(cis_valid_allocs)

	x.ref3a164861 = ref3a164861
	x.allocs3a164861 = allocs3a164861
	return ref3a164861, allocs3a164861

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilVerifyPoStResponse) PassValue() (C.fil_VerifyPoStResponse, *cgoAllocMap) {
	if x.ref3a164861 != nil {
		return *x.ref3a164861, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilVerifyPoStResponse) Deref() {
	if x.ref3a164861 == nil {
		return
	}
	x.StatusCode = (FCPResponseStatus)(x.ref3a164861.status_code)
	x.ErrorMsg = packPCharString(x.ref3a164861.error_msg)
	x.IsValid = (bool)(x.ref3a164861.is_valid)
}

// allocFilVerifySealResponseMemory allocates memory for type C.fil_VerifySealResponse in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilVerifySealResponseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilVerifySealResponseValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFilVerifySealResponseValue = unsafe.Sizeof([1]C.fil_VerifySealResponse{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilVerifySealResponse) Ref() *C.fil_VerifySealResponse {
	if x == nil {
		return nil
	}
	return x.refd4397079
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilVerifySealResponse) Free() {
	if x != nil && x.allocsd4397079 != nil {
		x.allocsd4397079.(*cgoAllocMap).Free()
		x.refd4397079 = nil
	}
}

// NewFilVerifySealResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilVerifySealResponseRef(ref unsafe.Pointer) *FilVerifySealResponse {
	if ref == nil {
		return nil
	}
	obj := new(FilVerifySealResponse)
	obj.refd4397079 = (*C.fil_VerifySealResponse)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilVerifySealResponse) PassRef() (*C.fil_VerifySealResponse, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd4397079 != nil {
		return x.refd4397079, nil
	}
	memd4397079 := allocFilVerifySealResponseMemory(1)
	refd4397079 := (*C.fil_VerifySealResponse)(memd4397079)
	allocsd4397079 := new(cgoAllocMap)
	allocsd4397079.Add(memd4397079)

	var cstatus_code_allocs *cgoAllocMap
	refd4397079.status_code, cstatus_code_allocs = (C.FCPResponseStatus)(x.StatusCode), cgoAllocsUnknown
	allocsd4397079.Borrow(cstatus_code_allocs)

	var cerror_msg_allocs *cgoAllocMap
	refd4397079.error_msg, cerror_msg_allocs = unpackPCharString(x.ErrorMsg)
	allocsd4397079.Borrow(cerror_msg_allocs)

	var cis_valid_allocs *cgoAllocMap
	refd4397079.is_valid, cis_valid_allocs = (C._Bool)(x.IsValid), cgoAllocsUnknown
	allocsd4397079.Borrow(cis_valid_allocs)

	x.refd4397079 = refd4397079
	x.allocsd4397079 = allocsd4397079
	return refd4397079, allocsd4397079

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilVerifySealResponse) PassValue() (C.fil_VerifySealResponse, *cgoAllocMap) {
	if x.refd4397079 != nil {
		return *x.refd4397079, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilVerifySealResponse) Deref() {
	if x.refd4397079 == nil {
		return
	}
	x.StatusCode = (FCPResponseStatus)(x.refd4397079.status_code)
	x.ErrorMsg = packPCharString(x.refd4397079.error_msg)
	x.IsValid = (bool)(x.refd4397079.is_valid)
}

// allocFilWriteWithAlignmentResponseMemory allocates memory for type C.fil_WriteWithAlignmentResponse in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilWriteWithAlignmentResponseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilWriteWithAlignmentResponseValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFilWriteWithAlignmentResponseValue = unsafe.Sizeof([1]C.fil_WriteWithAlignmentResponse{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilWriteWithAlignmentResponse) Ref() *C.fil_WriteWithAlignmentResponse {
	if x == nil {
		return nil
	}
	return x.refa330e79
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilWriteWithAlignmentResponse) Free() {
	if x != nil && x.allocsa330e79 != nil {
		x.allocsa330e79.(*cgoAllocMap).Free()
		x.refa330e79 = nil
	}
}

// NewFilWriteWithAlignmentResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilWriteWithAlignmentResponseRef(ref unsafe.Pointer) *FilWriteWithAlignmentResponse {
	if ref == nil {
		return nil
	}
	obj := new(FilWriteWithAlignmentResponse)
	obj.refa330e79 = (*C.fil_WriteWithAlignmentResponse)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilWriteWithAlignmentResponse) PassRef() (*C.fil_WriteWithAlignmentResponse, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa330e79 != nil {
		return x.refa330e79, nil
	}
	mema330e79 := allocFilWriteWithAlignmentResponseMemory(1)
	refa330e79 := (*C.fil_WriteWithAlignmentResponse)(mema330e79)
	allocsa330e79 := new(cgoAllocMap)
	allocsa330e79.Add(mema330e79)

	var ccomm_p_allocs *cgoAllocMap
	refa330e79.comm_p, ccomm_p_allocs = *(*[32]C.uint8_t)(unsafe.Pointer(&x.CommP)), cgoAllocsUnknown
	allocsa330e79.Borrow(ccomm_p_allocs)

	var cerror_msg_allocs *cgoAllocMap
	refa330e79.error_msg, cerror_msg_allocs = unpackPCharString(x.ErrorMsg)
	allocsa330e79.Borrow(cerror_msg_allocs)

	var cleft_alignment_unpadded_allocs *cgoAllocMap
	refa330e79.left_alignment_unpadded, cleft_alignment_unpadded_allocs = (C.uint64_t)(x.LeftAlignmentUnpadded), cgoAllocsUnknown
	allocsa330e79.Borrow(cleft_alignment_unpadded_allocs)

	var cstatus_code_allocs *cgoAllocMap
	refa330e79.status_code, cstatus_code_allocs = (C.FCPResponseStatus)(x.StatusCode), cgoAllocsUnknown
	allocsa330e79.Borrow(cstatus_code_allocs)

	var ctotal_write_unpadded_allocs *cgoAllocMap
	refa330e79.total_write_unpadded, ctotal_write_unpadded_allocs = (C.uint64_t)(x.TotalWriteUnpadded), cgoAllocsUnknown
	allocsa330e79.Borrow(ctotal_write_unpadded_allocs)

	x.refa330e79 = refa330e79
	x.allocsa330e79 = allocsa330e79
	return refa330e79, allocsa330e79

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilWriteWithAlignmentResponse) PassValue() (C.fil_WriteWithAlignmentResponse, *cgoAllocMap) {
	if x.refa330e79 != nil {
		return *x.refa330e79, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilWriteWithAlignmentResponse) Deref() {
	if x.refa330e79 == nil {
		return
	}
	x.CommP = *(*[32]byte)(unsafe.Pointer(&x.refa330e79.comm_p))
	x.ErrorMsg = packPCharString(x.refa330e79.error_msg)
	x.LeftAlignmentUnpadded = (uint64)(x.refa330e79.left_alignment_unpadded)
	x.StatusCode = (FCPResponseStatus)(x.refa330e79.status_code)
	x.TotalWriteUnpadded = (uint64)(x.refa330e79.total_write_unpadded)
}

// allocFilWriteWithoutAlignmentResponseMemory allocates memory for type C.fil_WriteWithoutAlignmentResponse in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilWriteWithoutAlignmentResponseMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilWriteWithoutAlignmentResponseValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFilWriteWithoutAlignmentResponseValue = unsafe.Sizeof([1]C.fil_WriteWithoutAlignmentResponse{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilWriteWithoutAlignmentResponse) Ref() *C.fil_WriteWithoutAlignmentResponse {
	if x == nil {
		return nil
	}
	return x.refc8e1ed8
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilWriteWithoutAlignmentResponse) Free() {
	if x != nil && x.allocsc8e1ed8 != nil {
		x.allocsc8e1ed8.(*cgoAllocMap).Free()
		x.refc8e1ed8 = nil
	}
}

// NewFilWriteWithoutAlignmentResponseRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilWriteWithoutAlignmentResponseRef(ref unsafe.Pointer) *FilWriteWithoutAlignmentResponse {
	if ref == nil {
		return nil
	}
	obj := new(FilWriteWithoutAlignmentResponse)
	obj.refc8e1ed8 = (*C.fil_WriteWithoutAlignmentResponse)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilWriteWithoutAlignmentResponse) PassRef() (*C.fil_WriteWithoutAlignmentResponse, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc8e1ed8 != nil {
		return x.refc8e1ed8, nil
	}
	memc8e1ed8 := allocFilWriteWithoutAlignmentResponseMemory(1)
	refc8e1ed8 := (*C.fil_WriteWithoutAlignmentResponse)(memc8e1ed8)
	allocsc8e1ed8 := new(cgoAllocMap)
	allocsc8e1ed8.Add(memc8e1ed8)

	var ccomm_p_allocs *cgoAllocMap
	refc8e1ed8.comm_p, ccomm_p_allocs = *(*[32]C.uint8_t)(unsafe.Pointer(&x.CommP)), cgoAllocsUnknown
	allocsc8e1ed8.Borrow(ccomm_p_allocs)

	var cerror_msg_allocs *cgoAllocMap
	refc8e1ed8.error_msg, cerror_msg_allocs = unpackPCharString(x.ErrorMsg)
	allocsc8e1ed8.Borrow(cerror_msg_allocs)

	var cstatus_code_allocs *cgoAllocMap
	refc8e1ed8.status_code, cstatus_code_allocs = (C.FCPResponseStatus)(x.StatusCode), cgoAllocsUnknown
	allocsc8e1ed8.Borrow(cstatus_code_allocs)

	var ctotal_write_unpadded_allocs *cgoAllocMap
	refc8e1ed8.total_write_unpadded, ctotal_write_unpadded_allocs = (C.uint64_t)(x.TotalWriteUnpadded), cgoAllocsUnknown
	allocsc8e1ed8.Borrow(ctotal_write_unpadded_allocs)

	x.refc8e1ed8 = refc8e1ed8
	x.allocsc8e1ed8 = allocsc8e1ed8
	return refc8e1ed8, allocsc8e1ed8

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilWriteWithoutAlignmentResponse) PassValue() (C.fil_WriteWithoutAlignmentResponse, *cgoAllocMap) {
	if x.refc8e1ed8 != nil {
		return *x.refc8e1ed8, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilWriteWithoutAlignmentResponse) Deref() {
	if x.refc8e1ed8 == nil {
		return
	}
	x.CommP = *(*[32]byte)(unsafe.Pointer(&x.refc8e1ed8.comm_p))
	x.ErrorMsg = packPCharString(x.refc8e1ed8.error_msg)
	x.StatusCode = (FCPResponseStatus)(x.refc8e1ed8.status_code)
	x.TotalWriteUnpadded = (uint64)(x.refc8e1ed8.total_write_unpadded)
}

// allocFil32ByteArrayMemory allocates memory for type C.fil_32ByteArray in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFil32ByteArrayMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFil32ByteArrayValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFil32ByteArrayValue = unsafe.Sizeof([1]C.fil_32ByteArray{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Fil32ByteArray) Ref() *C.fil_32ByteArray {
	if x == nil {
		return nil
	}
	return x.ref373ec61a
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Fil32ByteArray) Free() {
	if x != nil && x.allocs373ec61a != nil {
		x.allocs373ec61a.(*cgoAllocMap).Free()
		x.ref373ec61a = nil
	}
}

// NewFil32ByteArrayRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFil32ByteArrayRef(ref unsafe.Pointer) *Fil32ByteArray {
	if ref == nil {
		return nil
	}
	obj := new(Fil32ByteArray)
	obj.ref373ec61a = (*C.fil_32ByteArray)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Fil32ByteArray) PassRef() (*C.fil_32ByteArray, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref373ec61a != nil {
		return x.ref373ec61a, nil
	}
	mem373ec61a := allocFil32ByteArrayMemory(1)
	ref373ec61a := (*C.fil_32ByteArray)(mem373ec61a)
	allocs373ec61a := new(cgoAllocMap)
	allocs373ec61a.Add(mem373ec61a)

	var cinner_allocs *cgoAllocMap
	ref373ec61a.inner, cinner_allocs = *(*[32]C.uint8_t)(unsafe.Pointer(&x.Inner)), cgoAllocsUnknown
	allocs373ec61a.Borrow(cinner_allocs)

	x.ref373ec61a = ref373ec61a
	x.allocs373ec61a = allocs373ec61a
	return ref373ec61a, allocs373ec61a

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Fil32ByteArray) PassValue() (C.fil_32ByteArray, *cgoAllocMap) {
	if x.ref373ec61a != nil {
		return *x.ref373ec61a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *Fil32ByteArray) Deref() {
	if x.ref373ec61a == nil {
		return
	}
	x.Inner = *(*[32]byte)(unsafe.Pointer(&x.ref373ec61a.inner))
}

// allocFilPrivateReplicaInfoMemory allocates memory for type C.fil_PrivateReplicaInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilPrivateReplicaInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilPrivateReplicaInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFilPrivateReplicaInfoValue = unsafe.Sizeof([1]C.fil_PrivateReplicaInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilPrivateReplicaInfo) Ref() *C.fil_PrivateReplicaInfo {
	if x == nil {
		return nil
	}
	return x.ref81a31e9b
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilPrivateReplicaInfo) Free() {
	if x != nil && x.allocs81a31e9b != nil {
		x.allocs81a31e9b.(*cgoAllocMap).Free()
		x.ref81a31e9b = nil
	}
}

// NewFilPrivateReplicaInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilPrivateReplicaInfoRef(ref unsafe.Pointer) *FilPrivateReplicaInfo {
	if ref == nil {
		return nil
	}
	obj := new(FilPrivateReplicaInfo)
	obj.ref81a31e9b = (*C.fil_PrivateReplicaInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilPrivateReplicaInfo) PassRef() (*C.fil_PrivateReplicaInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref81a31e9b != nil {
		return x.ref81a31e9b, nil
	}
	mem81a31e9b := allocFilPrivateReplicaInfoMemory(1)
	ref81a31e9b := (*C.fil_PrivateReplicaInfo)(mem81a31e9b)
	allocs81a31e9b := new(cgoAllocMap)
	allocs81a31e9b.Add(mem81a31e9b)

	var cregistered_proof_allocs *cgoAllocMap
	ref81a31e9b.registered_proof, cregistered_proof_allocs = (C.fil_RegisteredPoStProof)(x.RegisteredProof), cgoAllocsUnknown
	allocs81a31e9b.Borrow(cregistered_proof_allocs)

	var ccache_dir_path_allocs *cgoAllocMap
	ref81a31e9b.cache_dir_path, ccache_dir_path_allocs = unpackPCharString(x.CacheDirPath)
	allocs81a31e9b.Borrow(ccache_dir_path_allocs)

	var ccomm_r_allocs *cgoAllocMap
	ref81a31e9b.comm_r, ccomm_r_allocs = *(*[32]C.uint8_t)(unsafe.Pointer(&x.CommR)), cgoAllocsUnknown
	allocs81a31e9b.Borrow(ccomm_r_allocs)

	var creplica_path_allocs *cgoAllocMap
	ref81a31e9b.replica_path, creplica_path_allocs = unpackPCharString(x.ReplicaPath)
	allocs81a31e9b.Borrow(creplica_path_allocs)

	var csector_id_allocs *cgoAllocMap
	ref81a31e9b.sector_id, csector_id_allocs = (C.uint64_t)(x.SectorId), cgoAllocsUnknown
	allocs81a31e9b.Borrow(csector_id_allocs)

	x.ref81a31e9b = ref81a31e9b
	x.allocs81a31e9b = allocs81a31e9b
	return ref81a31e9b, allocs81a31e9b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilPrivateReplicaInfo) PassValue() (C.fil_PrivateReplicaInfo, *cgoAllocMap) {
	if x.ref81a31e9b != nil {
		return *x.ref81a31e9b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilPrivateReplicaInfo) Deref() {
	if x.ref81a31e9b == nil {
		return
	}
	x.RegisteredProof = (FilRegisteredPoStProof)(x.ref81a31e9b.registered_proof)
	x.CacheDirPath = packPCharString(x.ref81a31e9b.cache_dir_path)
	x.CommR = *(*[32]byte)(unsafe.Pointer(&x.ref81a31e9b.comm_r))
	x.ReplicaPath = packPCharString(x.ref81a31e9b.replica_path)
	x.SectorId = (uint64)(x.ref81a31e9b.sector_id)
}

// allocFilPublicPieceInfoMemory allocates memory for type C.fil_PublicPieceInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilPublicPieceInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilPublicPieceInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFilPublicPieceInfoValue = unsafe.Sizeof([1]C.fil_PublicPieceInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilPublicPieceInfo) Ref() *C.fil_PublicPieceInfo {
	if x == nil {
		return nil
	}
	return x.refd00025ac
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilPublicPieceInfo) Free() {
	if x != nil && x.allocsd00025ac != nil {
		x.allocsd00025ac.(*cgoAllocMap).Free()
		x.refd00025ac = nil
	}
}

// NewFilPublicPieceInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilPublicPieceInfoRef(ref unsafe.Pointer) *FilPublicPieceInfo {
	if ref == nil {
		return nil
	}
	obj := new(FilPublicPieceInfo)
	obj.refd00025ac = (*C.fil_PublicPieceInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilPublicPieceInfo) PassRef() (*C.fil_PublicPieceInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd00025ac != nil {
		return x.refd00025ac, nil
	}
	memd00025ac := allocFilPublicPieceInfoMemory(1)
	refd00025ac := (*C.fil_PublicPieceInfo)(memd00025ac)
	allocsd00025ac := new(cgoAllocMap)
	allocsd00025ac.Add(memd00025ac)

	var cnum_bytes_allocs *cgoAllocMap
	refd00025ac.num_bytes, cnum_bytes_allocs = (C.uint64_t)(x.NumBytes), cgoAllocsUnknown
	allocsd00025ac.Borrow(cnum_bytes_allocs)

	var ccomm_p_allocs *cgoAllocMap
	refd00025ac.comm_p, ccomm_p_allocs = *(*[32]C.uint8_t)(unsafe.Pointer(&x.CommP)), cgoAllocsUnknown
	allocsd00025ac.Borrow(ccomm_p_allocs)

	x.refd00025ac = refd00025ac
	x.allocsd00025ac = allocsd00025ac
	return refd00025ac, allocsd00025ac

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilPublicPieceInfo) PassValue() (C.fil_PublicPieceInfo, *cgoAllocMap) {
	if x.refd00025ac != nil {
		return *x.refd00025ac, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilPublicPieceInfo) Deref() {
	if x.refd00025ac == nil {
		return
	}
	x.NumBytes = (uint64)(x.refd00025ac.num_bytes)
	x.CommP = *(*[32]byte)(unsafe.Pointer(&x.refd00025ac.comm_p))
}

// allocFilPublicReplicaInfoMemory allocates memory for type C.fil_PublicReplicaInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFilPublicReplicaInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFilPublicReplicaInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFilPublicReplicaInfoValue = unsafe.Sizeof([1]C.fil_PublicReplicaInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *FilPublicReplicaInfo) Ref() *C.fil_PublicReplicaInfo {
	if x == nil {
		return nil
	}
	return x.ref81b617c2
}

// Free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *FilPublicReplicaInfo) Free() {
	if x != nil && x.allocs81b617c2 != nil {
		x.allocs81b617c2.(*cgoAllocMap).Free()
		x.ref81b617c2 = nil
	}
}

// NewFilPublicReplicaInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFilPublicReplicaInfoRef(ref unsafe.Pointer) *FilPublicReplicaInfo {
	if ref == nil {
		return nil
	}
	obj := new(FilPublicReplicaInfo)
	obj.ref81b617c2 = (*C.fil_PublicReplicaInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *FilPublicReplicaInfo) PassRef() (*C.fil_PublicReplicaInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref81b617c2 != nil {
		return x.ref81b617c2, nil
	}
	mem81b617c2 := allocFilPublicReplicaInfoMemory(1)
	ref81b617c2 := (*C.fil_PublicReplicaInfo)(mem81b617c2)
	allocs81b617c2 := new(cgoAllocMap)
	allocs81b617c2.Add(mem81b617c2)

	var cregistered_proof_allocs *cgoAllocMap
	ref81b617c2.registered_proof, cregistered_proof_allocs = (C.fil_RegisteredPoStProof)(x.RegisteredProof), cgoAllocsUnknown
	allocs81b617c2.Borrow(cregistered_proof_allocs)

	var ccomm_r_allocs *cgoAllocMap
	ref81b617c2.comm_r, ccomm_r_allocs = *(*[32]C.uint8_t)(unsafe.Pointer(&x.CommR)), cgoAllocsUnknown
	allocs81b617c2.Borrow(ccomm_r_allocs)

	var csector_id_allocs *cgoAllocMap
	ref81b617c2.sector_id, csector_id_allocs = (C.uint64_t)(x.SectorId), cgoAllocsUnknown
	allocs81b617c2.Borrow(csector_id_allocs)

	x.ref81b617c2 = ref81b617c2
	x.allocs81b617c2 = allocs81b617c2
	return ref81b617c2, allocs81b617c2

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x FilPublicReplicaInfo) PassValue() (C.fil_PublicReplicaInfo, *cgoAllocMap) {
	if x.ref81b617c2 != nil {
		return *x.ref81b617c2, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Deref uses the underlying reference to C object and fills the wrapping struct with values.
// Do not forget to call this method whether you get a struct for C object and want to read its values.
func (x *FilPublicReplicaInfo) Deref() {
	if x.ref81b617c2 == nil {
		return
	}
	x.RegisteredProof = (FilRegisteredPoStProof)(x.ref81b617c2.registered_proof)
	x.CommR = *(*[32]byte)(unsafe.Pointer(&x.ref81b617c2.comm_r))
	x.SectorId = (uint64)(x.ref81b617c2.sector_id)
}

// unpackArgSFilPrivateReplicaInfo transforms a sliced Go data structure into plain C format.
func unpackArgSFilPrivateReplicaInfo(x []FilPrivateReplicaInfo) (unpacked *C.fil_PrivateReplicaInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.fil_PrivateReplicaInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocFilPrivateReplicaInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.fil_PrivateReplicaInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.fil_PrivateReplicaInfo)(h.Data)
	return
}

// packSFilPrivateReplicaInfo reads sliced Go data structure out from plain C format.
func packSFilPrivateReplicaInfo(v []FilPrivateReplicaInfo, ptr0 *C.fil_PrivateReplicaInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfFilPrivateReplicaInfoValue]C.fil_PrivateReplicaInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewFilPrivateReplicaInfoRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSFilPublicPieceInfo transforms a sliced Go data structure into plain C format.
func unpackArgSFilPublicPieceInfo(x []FilPublicPieceInfo) (unpacked *C.fil_PublicPieceInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.fil_PublicPieceInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocFilPublicPieceInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.fil_PublicPieceInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.fil_PublicPieceInfo)(h.Data)
	return
}

// packSFilPublicPieceInfo reads sliced Go data structure out from plain C format.
func packSFilPublicPieceInfo(v []FilPublicPieceInfo, ptr0 *C.fil_PublicPieceInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfFilPublicPieceInfoValue]C.fil_PublicPieceInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewFilPublicPieceInfoRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSFilCandidate transforms a sliced Go data structure into plain C format.
func unpackArgSFilCandidate(x []FilCandidate) (unpacked *C.fil_Candidate, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.fil_Candidate) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocFilCandidateMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.fil_Candidate)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.fil_Candidate)(h.Data)
	return
}

// unpackArgSFilPublicReplicaInfo transforms a sliced Go data structure into plain C format.
func unpackArgSFilPublicReplicaInfo(x []FilPublicReplicaInfo) (unpacked *C.fil_PublicReplicaInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.fil_PublicReplicaInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocFilPublicReplicaInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.fil_PublicReplicaInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.fil_PublicReplicaInfo)(h.Data)
	return
}

// packSFilPublicReplicaInfo reads sliced Go data structure out from plain C format.
func packSFilPublicReplicaInfo(v []FilPublicReplicaInfo, ptr0 *C.fil_PublicReplicaInfo) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfFilPublicReplicaInfoValue]C.fil_PublicReplicaInfo)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = *NewFilPublicReplicaInfoRef(unsafe.Pointer(&ptr1))
	}
}

// unpackArgSFilPoStProof transforms a sliced Go data structure into plain C format.
func unpackArgSFilPoStProof(x []FilPoStProof) (unpacked *C.fil_PoStProof, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.fil_PoStProof) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocFilPoStProofMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.fil_PoStProof)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.fil_PoStProof)(h.Data)
	return
}
